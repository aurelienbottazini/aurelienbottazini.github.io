Ruby version used for examples:

#+BEGIN_SRC ruby
'Aur√©lien'
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ruby :exports both :results output
puts RUBY_VERSION
puts __ENCODING__
#+END_SRC

#+RESULTS:
: 2.1.1
: US-ASCII

* Bootstrapping your ruby literacy
** Variables

   | Type     | Ruby Convention | Non-conventional             |
   |----------+-----------------+-----------------------------|
   | Local    | ~first_name~    | ~firstName~, ~firstName~    |
   | Instance | ~@first_name~   | ~@FirstName, @firstname~    |
   | Class    | ~@@first_name~  | ~@@First_name, @@firstName~ |
   | Global   | ~$FIRST_NAME~   | ~$first_name, $firstName~   |

   Instance variable are initialized to nil.
#+BEGIN_SRC ruby
@var
#+END_SRC

   Local variables are not initialized, not even to nil.
#+BEGIN_SRC ruby
var
#+END_SRC

#+BEGIN_EXAMPLE
undefined local variable or method `var' for main:Object (NameError)
#+END_EXAMPLE

** Installation directories

#+BEGIN_EXAMPLE
irb -simple-prompt -rrbconfig
#+END_EXAMPLE


   will launch irb and load rbconfig interface which contains a lot
   of compiled information about your ruby installation

   Then you can use ~RbConfig::CONFIG~ to get information about your
   ruby installation.

   Notable directories are

  | Term          | Directory contents                                                      |
  |---------------+-------------------------------------------------------------------------|
  | ~rubylibdir~  | Ruby Standard library                                                   |
  | ~bindir~      | Ruby command line tools                                                 |
  | ~archdir~     | Architecture-specific extensions and libraries (compiled binary files) |
  | ~sitedir~     | Your own or third party libraries (in Ruby)                            |
  | ~vendordir~   | Third-party extensions and libraries (in Ruby)                         |
  | ~sitelibdir~  | Your own Ruby language extensions  (in Ruby)                            |
  | ~sitearchdir~ | Your own Ruby language extensions (in C)                                |

** Load and Require

   ~$:~ is the load path global variable. You can add directories to load
   path. For example =~$: << '.'~=.
   One major difference between /load/ and /require/ if called more
   than once with the same arguments is that require doesn't reload
   files it's already loaded.

* Objects, methods and local variables
  method definitions evaluates to the symbol ~:m~ representing the
  name of the method that's just defined.

** ?
  Use question mark for method names that evaluate to ~true~ or ~false~.

** nil ~= false != true
   Everything in Ruby has a Boolean value.
   ~nil~ and ~false~ both have a Boolean value of /false/.
   Furthermore ~true~, ~nil~ and ~false~ are objects.
   Note that ~puts~ returns nil.

** Object behavior
   3 very useful and common functions
   + ~object_id~
   + ~respond_to?~
   + ~send~ (you can use ~__send__~ if you want to
     make sure you use Ruby's built in method send)

   #+BEGIN_SRC ruby
   if object.respond_to?(request)
     puts ticket.send(request)
   end
   #+END_SRC

** Arguments

   ~*~ allows any number of arguments and /sponges/ arguments if
   placed between other arguments.
   Use ~=~ to supply a default value for arguments.

  | method signature                        | sample call(s)                | variable assignments                                             |
  |-----------------------------------------+-------------------------------+-------------------------------------------------------------------|
  | ~def m(*a)~                             | ~m(1,2,3)~                    | ~a = [1,2,3]~                                                     |
  | ~def m(a, b=1)~                         | ~m(2)~                        | ~a = 2, b = 1~                                                    |
  |                                         | ~m(2,3)~                      | ~a = 2, b = 3~                                                    |
  | ~def m(a, b = 2, *c, d)~                | ~m(1, 3)~                     | ~a = 1, b = 2, c = [], d = 3~                                     |
  |                                         | ~m(1, 3, 5, 7)~               | ~a = 1, b = 3, c = [5], d = 7~                                    |
  |                                         | ~m(1, 3, 5, 7, 9)~            | ~a = 1, b = 3, c = [5, 7], d = 9~                                 |
  | ~def m(a:, b:)~                         | ~m(a:1, b:2)~                 | ~a = 1, b = 2~                                                    |
  | ~def m(a: 1, b: 2)~                     | ~m~                           | ~a = 1, b = 2~                                                    |
  |                                         | ~m(3, 4)~                     | ~a = 3, b = 4~                                                    |
  | ~def m(x, y, *z, a:1, b:, **c, &block)~ | ~m(1,2,3,4,5,b:10,p:20,q:30)~ | ~x = 1, y= 2, z=[3,4,5], a = 1, b = 10, c = {:p => 20, :q => 30}~ |
  | c here absorbs unknown named arguments  |                               |                                                                   |

  When using ~Hashes~ as arguments. If it is the last argument you
  can write it without curly braces

  #+BEGIN_SRC ruby
  add_to_database('Lille', country: 'France', postal_code: 62000)
  #+END_SRC

  If it is the first argument you must use parentheses (or ruby
  will think it is a block) and curly braces

  #+BEGIN_SRC ruby
  add_to_database({country => 'France', postal_code => 62000}, 'Lille')
  #+END_SRC

** Immediate values

   Some objects like /Integers/, /symbols/ and ~true~, ~false~,
   ~nil~ are stored in variables as immediate value. The variable
   holds the value itself rather than a reference to it.

   It follows that there is only one object ~1~, only one ~true~.
   And that's why there is no ~++~ operator in ruby. Because ~1++~
   means you'd be changing the number 1 to 2 and that makes no
   sense.

** Freeze, Dup and Clone
   You can freeze an object ruby to prevent and object from
   undergoing further changes.

   ~dup~ duplicates an object. ~clone~ duplicate an object and if
   the cloned object was frozen, the clone is also frozen.

* Organizing objects with classes
  Everything you handle in Ruby is either an object or a construct
  that evaluates to an object.
  Every object is an instance of some class.

  Class definitions evaluates to the last expression contained
  inside it, or ~nil~ if the block is empty.

** initialize
   Arguments used with ~new~ are automatically sent to ~initialize~.
** % sign technique
   Allows to use sprintf-like syntax. Run ri sprintf for full documentation.
   #+BEGIN_SRC ruby
   price = 2.84839849
   p "#{"%.2f" % price}"
   #+END_SRC

** assignment-like methods

  #+BEGIN_SRC ruby
  ticket.price=(63.00)
  ticket.price = 63.00
  #+END_SRC

   The second version is syntactic sugar for the first one. It is
   important to understand and remember. ~=~ is a method (like
   other operators) and can be overloaded.

** setter methods
   They behave like assignment. They return the value of the
   expression rather than the last expression evaluated during
   execution (for example when your assignment methods returns a
   string "Hah ha!")

  #+BEGIN_SRC ruby
  class Ticket
    def price=(price)
      @price = price
      return 'ahah'
    end

  end

  if (Ticket.new.price = 65) == 65 # true
    puts 'my return value is 65' #gets printed
  end
  #+END_SRC

** attributes

  | method name     | effect                                             | example                | equivalent code   |
  | ~attr_reader~   | creates a read method                              | ~attr_reader :venue~   | def venue         |
  |                 |                                                    |                        | @venue            |
  |                 |                                                    |                        | end               |
  | ~attr_writer~   | creates a writer method                            | ~attr_writer :price~   | def price=(price) |
  |                 |                                                    |                        | @price = price    |
  |                 |                                                    |                        | end               |
  | ~attr_accessor~ | creates reader and writer method                   | ~attr_accessor :price~ |                   |
  | ~attr~          | creates a reader method                            | ~attr :venue~          |                   |
  |                 | and a writer method if the second argument is true | ~attr :price, true~    |                   |

   Those family methods are defined in /Module/

** Subclass

   ~<~ designates a subclass.

  #+BEGIN_SRC ruby
  class Publication
  end

  class Magazine < Publication
  end

  #+END_SRC

** Superclass & Modules
   A Ruby /class/ can have only one /superclass/ (/single
   inheritance/).
   Ruby provides modules that you can /mix in/ your class's family
   tree to provide as many methods for your objects as you need.

** ~BasicObject~, ~Object~ & ~Kernel~

   ~BasicObject~ comes before ~Object~ in the ruby family tree.
   ~BasicObject~ offers a blank state object. an object with
   almost no methods. At the time of writing (Ruby 2.1),
   ~BasicObject~ has 7 instance methods and ~Object~
   about 55.

   ~Kernel~ module contains the majority of the methods common to
   all objects

   ~BasicObject~, ~Object~ & ~Kernel~ are written in C. Here is a
   Ruby mock-up of their relationship

  #+BEGIN_SRC ruby
  class BasicObject
    # 7 methods
  end
  module Kernel
    # over 100 method definitions
  end
  class Object < BasicObject
    include Kernel
  end
  #+END_SRC

** Methods & Constant notation

   + ~Ticket#price~: instance method ~price~ in the /class/
     ~Ticket~
   + ~Ticket.most_expensive~: /class/ method ~most_expensive~ in
     the class Ticket
   + ~Ticket::most_expensive~: /class/ method ~most_expensive~ in
     the class Ticket
   + ~Ticket::VENUES~: constant ~VENUES~ in class ~Ticket~

**  Constants

    It is possible to perform an assignment on a constant you
    already assigned.

  #+BEGIN_SRC ruby
  A = 1
  A = 2
  #+END_SRC

    You will get a warning

  #+BEGIN_SRC ruby
  venues = Ticket::VENUES
  venues << 'High School Gym'
  #+END_SRC

    no warning because there is no redefinition of a constant. We
    are modifying an array and array has no knowledge it has been
    assigned to a constant.

** ~inspect~
   You can override it and have useful info about your custom class.

* Modules and program organization

  Modules don't have instances. It follows that entities or things
  are best modeled in classes and characteristics or properties
  are best encapsulated in modules.

  The /class/ of ~Class~ and ~Module~ is /class/. The /superclass/ of
  ~Class~ is ~Module~. The /superclass/ of ~Module~ is object.

  modules get /mixed in/ to classes using ~include~ or ~prepend~.
  A /mixed in/ module is referred as a /mix in/.

#+BEGIN_SRC ruby
class ModuleTester
  include MyFirstModule
end
#+END_SRC

  The main difference between inheriting from a /class/ and
  /modules/ is that you can /mix in/ more that one module

** Class and Module naming

  It is common to have /class/'s name as noun and /module/'s as an adjective

  #+BEGIN_SRC ruby
  class Stack
    include Stacklike
  end
  #+END_SRC

** ~method_missing~

  Get called as a last resort for unmatched messages. You can
  override ~method_missing~

  A good example of a ~method_missing~ override:

  #+BEGIN_SRC ruby
  class Person
    def self.method_missing(m, *args)
      method = m.to_s
      if method.start_with?('all_with_')
        # Handle request here"
      else
        super
      end
    end
  end
  #+END_SRC

** including a module several times

   Re-including a /module/ does not do anything as the module is
   already in the search path. In the following example, if /N/ and
   /M/ have some methods with the same name, the method defined in
   /N/ will be called.

  #+BEGIN_SRC ruby
  class C
    include M
    include N
    include M
  end
  #+END_SRC

** ~prepend~

   ~prepend~ appeared with Ruby 2. The difference between
   ~include~ and ~prepend~ is that when you ~prepend a module~,
   the object looks in the module first instead of looking in the
   class.

** method look-up summary

   To look for a method, an object looks in:

   1. Modules pre-pended
   2. singleton class
   3. It's class
   4. Modules in it class
   5. Modules pre-pended to its superclass
   6. It's class superclass
   7. Modules included in its superclass
   8. and so on up to ~BasicObject~

   A method defined as a singleton method of a class object can
   also be called on sub-classes of that class. The singleton
   class is considered the ancestor of the singleton class of
   sub-classes.

** ~super~

   + Called with no arguments, ~super~ automatically forwards
     arguments passed to the method from which it's called.
   + with an empty argument list ~super()~ sends no
     argument.
   + called with specific arguments ~super(a, b, c)~ sends those
     arguments.

** Nesting modules and classes

  #+BEGIN_SRC ruby
  module Tools
    class Hammer
    end
  end
  #+END_SRC

   Used to separate name-spaces for classes, modules and methods.
   However if you see a construct like ~Tools::Hammer~ you can't
   say from that construct if ~Hammer~ is a class or a module. You
   know it through the documentation or because you wrote the
   code. The notation in itself does not tell you everything.

* The default Object (self), scope & visibility

  | Context              | Example                          | Which object is self?               |
  |----------------------+----------------------------------+-------------------------------------|
  | Top level of program | Any code                         | ~main~                              |
  | Class definition     | class C                          | class object C                      |
  |                      | self                             |                                     |
  | Module definition    | module M                         | module object M                     |
  |                      | self                             |                                     |
  | Method definitions   | 1. Top level                     | whatever object is self             |
  |                      | def method_name                   | when the method is called           |
  |                      | self                             |                                     |
  |                      | 2. class instance-method         | An instance of C                    |
  |                      | class C                          |                                     |
  |                      | def method_name                   |                                     |
  |                      | self                             |                                     |
  |                      | 3. module instance-method        | - Individual object extended by M    |
  |                      | module M                         | - Instance of class that mixes in M |
  |                      | def method_name                   |                                     |
  |                      | self                             |                                     |
  |                      | 4. Singleton method on an object | Obj                                 |
  |                      | def obj.method_name               |                                     |
  |                      | self                             |                                     |


**  Don't hard code class names.
    It is bad in case you want to rename  your class. Instead use self

  #+BEGIN_SRC ruby
  class C
    def C.y # bad
    end

    def self.x # good
    end
  end
  #+END_SRC

** instance variables
   every instance variable belongs to whatever object is the
   current object (/self) at that point.

    #+BEGIN_SRC ruby
    class C
      p self
      @v = "top level instance variable "
      p @v

      def show_v
        p self
        p @v
      end
    end

    c = C.new
    c.show_v
    #+END_SRC

   will return

    #+BEGIN_EXAMPLE
    C
    "top level instance variable"
    #<C:0x007fe37388d9d0>
    nil
    #+END_EXAMPLE

   The two variables ~@v~ are different


** built-in classes
   You can create you own /string/ class

    #+BEGIN_SRC ruby
    class MyClass
      class String

      end
      def initialize
        String.new
    end
    #+END_SRC

   Here the ~String~ used will be the new one defined in
   ~MyClass~. To use the build in Ruby ~String~ you can use ~::String.new~.
   ~::~ in front of a constant means start the search for this at
   the top level.

** class variables (@@)

   class variables are class-hierarchy scoped.

   #+BEGIN_SRC ruby
   class Parent
     @@value = 100
   end

   class Child < Parent
     @@value = 200
   end

   class Parent
     puts @@value
   end
   #+END_SRC

   Here 200 will get printed


** public, private, protected
   you either do
   ~private :first_method, :second_method, :third_method~. To make
   those three methods private. Or Use ~private~ as a switch
   without arguments then ll methods below ~private~ in your class
   will be private.

*** private setter methods
    you can omit ~self~ when defining private access. It won't
    clash with an hypothetic class variable. Ruby is smart enough
    to understand what you mean.

    #+BEGIN_SRC ruby
    class Dog
      attr_reader :age, :dog_years
      def dog_years=(years)
        @dog_years = years
      end
      def age=(years)
        @age = years
        self.dog_years = years * 7 # = @dog_years = years * 7
      end
      private :dog_years=
    end

    luigi = Dog.new
    luigi.age = 10
    #+END_SRC

** top level method

#+BEGIN_SRC ruby
def talk
  puts 'hello'
end
#+END_SRC

   is equivalent to

#+BEGIN_SRC ruby
class Object
  private
  def talk
    puts 'hello'
  end
end
#+END_SRC
* Control-flow techniques
** if

#+BEGIN_SRC ruby
if x > 10
  puts x
end

if x > 10 then puts x end

if x > 10; puts x; end

puts x if x > 10
#+END_SRC

   If an ~if~ statement does not succeed it returns ~nil~
   It it succeeds the entire statement evaluates to whatever is
   represented by the code in the successful branch.

** unless
   same as ~if not~ or ~if!~

** case
   At most one match will succeed and have its code executed.
   You can put more than one possible match in a single ~when~

#+BEGIN_SRC ruby
case answer
when 'y', 'yes'
  puts 'affirmative!'
when 'n', 'no'
  puts 'negative!'
else
  puts 'not sure'
end
#+END_SRC

** /===/
   For ~String~ and any object that does not override it, ~===~
   works the same as ~==~. Every class can define its own ~===~
   method. It is used in /case when/ equality logic.

** loop

   loop is an iterator. In Ruby an iterator is a method that
   expects you to provide a code block.

#+BEGIN_SRC ruby
loop { puts 'looping forever' }
#+END_SRC

#+BEGIN_SRC ruby
n = 1
loop do
  n += 1
  next unless n == 10
  break
end
#+END_SRC

   Here is how we can write loop

#+BEGIN_SRC ruby
def my_loop
  yield while true
end
#+END_SRC

** while and until modifiers

#+BEGIN_SRC ruby
n += 1 until n == 10
n += 1 while n < 10
#+END_SRC

** for

#+BEGIN_SRC ruby
numbers = [0, 10, 20, 30, 40, 50]
for n in numbers
  puts n
end
#+END_SRC

** curly braces vs do/end code block

   The difference between the two is a difference in precedence

#+BEGIN_SRC ruby
puts [1, 2, 3].map { |n| n * 10 }
# is like
puts ([1, 2, 3].map { |n| n * 10 })
#+END_SRC
   will output 10, 20 , 30

#+BEGIN_SRC ruby
puts [1, 2, 3].map do |n| n * 10 end
# is like
puts ([1, 2, 3].map) do |n| n * 10 end
# is like
puts [1, 2, 3].map
#+END_SRC
   will output an enumerator

** each and map

   - ~each~ returns its receiver
   - ~map~ returns a new array


**  Block parameters and scope

    If you have a variable of a given name in scope and also use
    that name as one of your block parameters, then the two
    variables are not the same as each other.
    You can use this to your advantage to make sure a temporary
    variable inside a block does not reuse a variable from outside
    the block

#+BEGIN_SRC ruby
x = "original x"
3.times do |i;x|
  x = i
end
x
#+END_SRC

    ~;~ indicates the block needs its own x.

** rescue

#+BEGIN_SRC ruby
begin
  #some code
rescue ArgumentError => e
#rescue code
  puts e.backtrace
  puts e.message
ensure
  #make sure this runs
end
#+END_SRC

   if you put rescue at the end of a method you don't need to say
   begin explicitly. Rescue will govern the entire method block

#+BEGIN_SRC ruby
def method_name
  puts 'hello'
  rescue
  puts 'rescued'
end
#+END_SRC

* Built in essentials
** Literal constructors
   Special notation instead of a call to ~new~ to create a new
   object of that class.

   | Class         | Examples(s)              |
   |---------------+--------------------------|
   | String        | "Hello"                  |
   |               | 'hello'                  |
   | Symbol        | :hello                   |
   | Array         | [1, 2, 3, 4]             |
   | Hash          | { 'Hello' -> 'Bonjour' } |
   | Range         | 0..9                     |
   |               | 0...10                   |
   | Regexp        | /([a-z]+)/               |
   | Proc (lambda) | ->(x, y) { x * y }       |

** Shortcut operators (syntactic sugar)

   Ruby has shortcut operators like ~||=~, ~+=~, ~-=~, ~*=~, ~&=~
   (bitwise AND), ~|=~ (bitwise OR), ~^=~ (bitwise EXCLUSIVE OR)

   If you define a ~+~ method you can use the ~+=~ syntax.
   Similarly if you define a ~-~ method you can use the ~-=~ syntax
   and so on for all other operators.

   Shortcut operators are:
   | Category      | Operators          |
   |---------------+--------------------|
   | Arithmetic    | ~+ - * / % **~     |
   | Data          | ~[] []= <<~        |
   | Comparison    | ~<=> == > < >= <=~ |
   | Case equality | ~===~              |
   | Bitwise       | \vert & ^              |

** Unary operators

   ~+~ and ~-~ as in ~+1~ and ~-1~ can be customized

#+BEGIN_SRC ruby
def +@
end

def -@
end
#+END_SRC

   You can customize ~!~ which also gives you ~not~

#+BEGIN_SRC ruby
def !
  #some code
end
#+END_SRC

** ~dangerous_method!~

   When you have a ! at the end of a method name. It usually means
   this methods permanently modifies its receiver. But It is not
   always the case. Especially when ! methods don't have non-bang
   equivalent.
   Ex: ~String.clear~. No ! but it changes the receiver.

   + Don't use ! except in M/M! methods pars
   + Don't equate ! with destructive behavior or vice versa
     It can mean something else.

** conversions

   + ~to_s~
     used by certain methods like ~puts~ and string interpolation. If you write your
     own ~to_s~ for a class you can take advantage of it.
   + ~to_a~ and ~*~
     The ~*~ turns any array into the equivalent of a bare list
     #+BEGIN_SRC ruby :exports both
     [*[1, 2, 3, 4, 5]] == [1, 2, 3, 4, 5]
     #+END_SRC

     #+RESULTS:
     : true

   + ~to_i~, ~Integer~, ~to_f~, ~Float~
     To convert integers and float. ~Integer~ and ~Float~ are
     stricter versions
   + Role-playing
     + ~to_str~
       If you want to be able to add a string with your object,
       you can define ~to_str~ for your object. ~to_str~ is used
       by ruby for /String#+/ and /String#<</
     + ~to_ary~
       To use ruby methods like /Array#concat/

** Comparisons
   if you define ~==~, you automatically define ~!=~ for your
   object.
   ~==~ and ~eql?~ are usually redefined to do meaningful work.
   ~equal?~ is usually left alone to check whether two objects are
   exactly the same object.

*** Comparable module
    If you want objects of ~MyClass~ to have the full comparison
    suite:

    + mix-in ~Comparable~
    + Define ~<=>~ (spaceship operator) for your class
      ~<=>~ can return -1 (less than), 0 (equal) and 1 (greater
      than)
** Inspecting

   ~String.methods.sort~
   ~String.instance_methods.sort~
   Use ~String.instance_methods(false).sort~ to not see instance
   methods provided by class's ancestors.

#+BEGIN_SRC ruby :exports both
str = 'ok'
def str.shout
  self.upcase
end
str.singleton_methods
#+END_SRC

#+RESULTS:
| :shout |

** ~try_convert~
   ~try_convert~ looks for a conversion method on argument object.
   If it exists, it gets called, if not it returns ~nil~. If the
   object returned class is different that the class to which
   conversion is attempted it returns a fatal error.

#+BEGIN_SRC ruby :exports both
obj = Object.new
Array.try_convert(obj)
#+END_SRC

#+RESULTS:
: nil

#+BEGIN_SRC ruby :exports both
obj = Object.new
def obj.to_ary
  [1, 2, 3]
end
Array.try_convert(obj)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

* Strings, symbols and other scalar objects
  A string literal is enclosed between ~"~ or ~'~ quotation marks
  string interpolation does not work with ~'~
** String interpolation

#+BEGIN_SRC ruby :results output :exports both
first_name = 'Auray'
puts "I'm #{first_name}"
#+END_SRC

#+RESULTS:
: I'm Auray

   You can also create a string with ~%charDELIMITERtextDELIMITER~. ~char~ can be
   + ~%q~. Creates a single-quote string
   + ~%Q~. Creates a double-quote string
   + ~%~. Creates a double-quote string

     delimiter can be any of two same character as long as you
     match it on both end of the string. It can be a pair of
     braces too.

** /Here/ document or /here-doc/

#+BEGIN_SRC ruby :exports both
too = 'too'
text = <<EOM
This text is splendid.
Full of words, lines & punctuations.
And with interpolation #{too}
EOM
#+END_SRC

#+RESULTS:
: This text is splendid.
: Full of words, lines & punctuations.
: And with interpolation too

   You can add single quotes for single quoted /here-doc/

#+BEGIN_SRC ruby :exports both
var_too = 'too'
text = <<'EOM'
No interpolation #{var_too}
EOM
#+END_SRC

#+RESULTS:
: No interpolation #{var_too}

   /EOM/ does not have to be the last thing on the line

#+BEGIN_SRC ruby :exports both
a = <<EOM.to_i * 10
5
EOM
#+END_SRC

#+RESULTS:
: 50

#+BEGIN_SRC ruby :exports both :results output
array = [1, 2, 3, <<EOM.to_i, 5]
4
EOM
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

#+BEGIN_SRC ruby
long_args(a, b, <<EOM)
http://supersupersupersupersupersupersuperlongurl.com
EOM
#+END_SRC

** Basic string manipulation

*** Selection
   + negative numbers index from the end of the string
#+BEGIN_SRC ruby :exports both
  string = "ruby is cool"
  string[-1]
#+END_SRC

#+RESULTS:
: l

   + You can ask for a sub-string
#+BEGIN_SRC ruby :exports both
string = "ruby is cool"
string[5, 7]
#+END_SRC

#+RESULTS:
: is cool

   + You can provide a range
#+BEGIN_SRC ruby :exports both
 string = "ruby is cool"
string[5..11]
#+END_SRC

#+RESULTS:
: is cool

#+BEGIN_SRC ruby :exports both
string = "ruby is cool"
string[5...11]
#+END_SRC

#+RESULTS:
: is coo

   + You can use sub-string search
#+BEGIN_SRC ruby :exports both
string = "ruby is cool"
string['is']
#+END_SRC

#+RESULTS:
: is

  + And regular expression
#+BEGIN_SRC ruby :exports both
string = "ruby is cool"
string[/co+l/]
#+END_SRC

#+RESULTS:
: cool

*** changing strings
  + You can change part of a string using the same selection arguments
#+BEGIN_SRC ruby :exports both
string = "ruby is cool"
string['cool'] = 'great'
string
#+END_SRC

#+RESULTS:
: ruby is great

  + You can combine strings
    With ~+~ the string you get back is always a new string. With
    ~<<~ we append permanently. No new string.

** Enumerable strings
   + ~each_byte~ and ~bytes~
   + ~each_char~ and ~chars~
   + ~each_codepoint~ and ~codepoints~ provides character codes, one code per
     character. Sometimes due to encoding the number of bytes is
     greater than the number of code points.
   + ~each_line~ and ~lines~
     The string is split at each occurrence of ~$/~. Which is the
     end of lines by default.

** Querying strings
   + ~String#include?('cool')~
   + ~String#start_with?('ruby')~
   + ~String#empty?~
   + ~String#size~
   + ~String#count('a')~, range of letters ~String#count('a-c')~ and you can
     combine arguments ~String#count('a-c', '^b' )~ (any letters from a
     to c that is not b)
   + ~String#index('cool')~
   + ~String#ord~ gives ordinal code of first character. Reverse
     operation is ~String#chr~

** String comparison
   + ~==~ for equality of content
   + ~String#equal?~ for equality of object

** transformations

   + ~String#upcase~
   + ~String#downcase~
   + ~String#upcase~
   + ~String#swapcase~
   + ~String#capitalize~
   + ~String#rjust(5)~ and ~String#ljust(5)~ add padding to the
     right of left with either blank spaces or a char if you add a
     second char parameter.
   + ~String#center(5)~. Same as /rjust/ and /ljust/ for parameters
   + ~String#strip~, ~String#lstrip~ & ~String#rstrip~ removes
     white-spaces
   + ~String#chop~ to remove a character at the end of the string
   + ~String#chomp~ to remove a newline character. You can target
     other characters or strings by providing an argument ~String#chomp('ab')~
   + ~String#clear~ clears the receiver. No ! but it changes the receiver.
   + ~String#replace~
   + ~String#delete~ same rules for arguments as with count.
   + ~String#succ~ increment letters in a string. Handy when you
     need a batch of generated unique strings.

** Conversions
   ~to_sum~, ~to_f~, ~to_i~
   You can provide a parameter to ~to_i~ to specify a base.
   ~.oct~ for octal and ~.hex~ for hexadecimal.

** Encoding
   In Ruby 2 the default encoding for ruby scripts is UTF-8.

   you can use ~__ENCODING__~ to know the encoding value. Directly
   in the file. If you run this command on the command line
   through ~$ ruby -e 'puts __ENCODING__~ you will get the current
   locale setting which can differ.

   You can use a magic comment at the top of the file ~# encoding:
   encoding_Value~ to change the encoding of a file.

*** Strings

    ~String#encoding~ to get the encoding.

    You can encode a string in a different encoding as long as the
    conversion is permitted. This is called trans-coding.
    ~String.encode('US-ASCII')~. The bang version changes the
    encoding of the string permanently.

    You can force an encoding ~String#force_encoding('US-ASCII')~

    You can represent characters with escape sequence. ~\x~ for
    two digit hexadecimal numbers representing a byte. ~\u~
    followed by a UTF-8 code to insert the corresponding
    character. By doing this you can change a string encoding to
    UTF-8 (if it was in ASCII and the character inserted does not
    exist in ASCII).

** XOR and strings
   If you XOR two times the same things you get back the original
   value.
   So ~(a^b)^b = a~. This is an interesting obfuscation technique
   with strings.

#+BEGIN_SRC ruby :exports both :results output
  class String
    def ^(key)
      kenum = key.each_byte.cycle
      each_byte.map {|byte| byte ^ kenum.next }.pack("C*").force_encoding(self.encoding)
    end
  end

  puts 'hello' ^ 'secret key' ^ 'secret key'
#+END_SRC

#+RESULTS:
: hello

   Here ~pack("C*")~ turns an array into a string. The ~C*~
   arguments tells pack to treat each element of the array as an
   unsigned integer representing a single character (~C~) and process
   all of them (~*~).

** Symbols

   literal constructor ~:symbol_name~

   + symbols are immutable
   + symbols are unique. Thus there is no point in having
     constructor for them. They are like integers in that respect

   When you bin a variable to a symbol you bind its value, not a
   reference to it.

   You can list all symbols with ~Symbol.all_symbols~

   If you want to check if a symbol exist you can use /grep/

#+BEGIN_SRC ruby
Symbol.all_symbols.grep(/abc/)
#+END_SRC

   Don't use ~include?(:abc)~ because this very act creates the
   symbol!

   Symbols appears most of the times in method arguments and hash
   keys. They are better for hash keys because ruby can process
   them faster and they look good as hash keys. Ruby also use a
   convenient way to use symbol as hash keys

   The following two are equivalent
#+BEGIN_SRC ruby
hash = { :name => 'David', :age => 35 }
hash = { name: 'David', age: 35}
#+END_SRC

** Numerical object

   At the top /Numeric/.
   /Float/ and /Integer/ below.
   /Fixnum/ and /Bignum/ below Integer. Ruby handles the
   conversion automatically when you need /Bignum/.

   With divisions, when you want integers you have to specify it.

#+BEGIN_SRC ruby :exports both
3 / 2
#+END_SRC

#+RESULTS:
: 1


#+BEGIN_SRC ruby :exports both
3 / 2.0
#+END_SRC

#+RESULTS:
: 1.5

   Hexadecimals with leading 0x

#+BEGIN_SRC ruby :exports both
0x12 + 10
#+END_SRC

#+RESULTS:
: 28

   Octals when leading 0

#+BEGIN_SRC ruby :exports both
012 + 10
#+END_SRC

#+RESULTS:
: 20

** Times and dates

   3 classes. /Time/, /Date/ and /DateTime/

#+BEGIN_SRC ruby
require 'time'
require 'date' #provides both Date and Datetime
#+END_SRC

   You can query for ~leap?~ years and ~dst?~ (daylight saving
   time)
   There is an ~strftime~ methods to format
   Precooked format /rfc2822/ for email and ~httpdate~ (RFC 2616
   standard).
   You can use ~upto~ and ~downto~ to iterate over a range of them

#+BEGIN_SRC ruby :exports both
require 'date'
d = Date.today
next_week = d + 7

d.upto(next_week)
#+END_SRC

#+RESULTS:
: #<Enumerator: #<Date: 2014-11-15 ((2456977j,0s,0n),+0s,2299161j)>:upto(#<Date: 2014-11-22 ((2456984j,0s,0n),+0s,2299161j)>)>

* Collection and container objects

  Ruby implements collections principally through classes that min
  in ~Enumerable~.

  ~with_index~ is a method which yields a counter value along with
  the enumerator. Pretty new and preferable to ~each_with_index~.

** Array
   You can create an array with
   + ~Array.new~
#+BEGIN_SRC ruby :exports both :results output
puts Array.new(3)
#+END_SRC

#+RESULTS:
:
:
:

   Be careful with the following example. The 3 elements of the
   array are initialized with the same string. If you modify it
   for one element, you modify it for all elements of the Array.


#+BEGIN_SRC ruby :exports both
Array.new(3, 'abc')
#+END_SRC

#+RESULTS:
| abc | abc | abc |

   With a block, all 3 strings are different

#+BEGIN_SRC ruby :exports both
Array.new(3) { 'abc'}
#+END_SRC

#+RESULTS:
| abc | abc | abc |

#+BEGIN_SRC ruby :exports both
n = 0
Array.new(3) { n += 1; n * 10}
#+END_SRC

#+RESULTS:
| 10 | 20 | 30 |


   + []
   + top level method ~Array~
     If an element has an ~to~ary~ method the ~Array~ call use
     that method. If not it tries with ~to_a~. If not it wraps the
     object in an Array

#+BEGIN_SRC ruby :exports both
string = "cool"
def string.to_a
  split(//)
end
Array(string)
#+END_SRC

#+RESULTS:
| c | o | o | l |

   + special notations %w{} and #i{}

     %w single quoted and %W double quoted
#+BEGIN_SRC ruby :exports both
%w{ It is a small world }
#+END_SRC

#+RESULTS:
| It | is | a | small | world |

~%i~ and ~%I~ for array of symbols single and double quoted

#+BEGIN_SRC ruby
%i{It is a small world}
#+END_SRC

*** Inserting, retrieving and removing from an array

   | Sample call                    | Meaning                                           |
   |--------------------------------+---------------------------------------------------|
   | ~a[3, 2]~                      | select two elements starting at index 3           |
   | ~array.values_At(0,3)~         | select values at index 0 and 3                    |
   | ~a.unshift(0)~                 | adds 0 at start of array                          |
   | ~a.shift(n=1)~                 | remove n elements from beginning of array         |
   | ~a.pop(n=1)~                   | remove n elements from end of array               |
   | ~a.push(6,7,8)~                | adds 6, 7 and 8 at the end of the array           |
   | ~a << 5~                       | add 5 at the end of the array                     |
   | ~[1, 2, 3].concat([4, 5, 6])~  | ~[1, 2, 3, 4, 5, 6]~ changes permanently receiver |
   | ~[1, 2, 3] + [4, 5, 6]~        | ~[1, 2, 3, 4, 5, 6]~ creates a new array          |
   | ~[1, 2, 4].replace([4, 5, 6])~ | ~[4, 5, 6]~ Keeps same object                     |
   | ~[1, [2, [3, 4]]].flatten~     | ~[1, 2, 3]~ flattens completely                   |
   | ~[1, [2, [3, 4]]].flatten(1)~  | ~[1, 2, [3, 4]]~ flattens one level               |
   | ~[1, 2, 3, 4].reverse~         | ~[4, 3, 2, 1]~                                    |
   | ~['abc', 'def'].join(arg='')~  | ~abcdef~ join all argument and returns a string   |
   | ~[1, 1, 2, 3].uniq~            | ~[1, 2, 3]~                                       |
   | ~[1, nil, 2, nil].compact~     | ~[1, 2]~ removes nil                              |


*** Querying

    | Sample call             | Meaning                          |
    |-------------------------+----------------------------------|
    | ~a.size~ and ~a.length~ | Number of elements in array      |
    | ~a.empty?~              | True if a is empty               |
    | ~a.include?(element)~   | True if array includes ~element~ |
    | ~a.count(element)~      | number of ~element~              |
    | ~a.first(n=1)~          | first n elements                 |
    | ~a.last(n=1)~           | last n elements                  |
    | ~a.smaple(n=1)~         | n random elements                |

** Hashes
   Hashes are now ordered collections.

   You can use ~(key, value)~ in blocks to get the hash element
   array distributed across two parameters.
   Key values are unique
   Hash provides quick look-up in better than linear time

#+BEGIN_SRC ruby
hash = { red: 'ruby', white: 'diamond', green: 'emerald'}
output = ''
hash.each.with_index do |(key, value), i|
  output << "PAIR #{i} is #{key}/#{value}\n"
end
output
#+END_SRC

   You can create an Hash with:
   + ~{}~
     #+BEGIN_SRC ruby :exports both
     h = {}
     #+END_SRC

     #+RESULTS:
     : {}

   + ~Hash.new~
     #+BEGIN_SRC ruby :exports both
     h = Hash.new(3) #argument serves as default value for nonexistent hash keys
     h[:my_key]
     #+END_SRC

     #+RESULTS:
     : 3

     You can use blocks too!
     #+BEGIN_SRC ruby :exports both
     h = Hash.new {|hash, key| hash[key] = 0 }
     h[:my_key]
     #+END_SRC

     #+RESULTS:
     : 0

   + ~Hash.[]~
     If you provide an odd number of argument a fatal error is raised
     #+BEGIN_SRC ruby
     Hash['France', 'fr', 'USA', 'us']
     #+END_SRC

     #+RESULTS:
     | France | => | fr | USA | => | us |

   + ~Hash~
     Calls ~to_hash~ on its single argument. Except if you pass it
     an empty ~Array~ or ~nil~ it returns an empty hash ~{}~

     #+BEGIN_SRC ruby :exports both
       Hash([])
     #+END_SRC

     #+RESULTS:
     : {}

*** Hash methods

   | Sample call                        | Meaning                                               |
   |------------------------------------+-------------------------------------------------------|
   | ~=h['France'] = 'fr'=~             | adds a key/value pair                                 |
   | ~h.store('France', 'fr')~          | adds a key/value pair                                 |
   | ~h['France']~                      | fetch value                                           |
   | ~h.fetch('France')~                | fetch value, raises an exception for non existent key |
   | ~h.values_att('France', 'USA')~    | return arrays of value                                |
   | ~h1.update(h2)~ or ~h1.merge!(h2)~ | h1 keys are overwritten with corresponding h2 keys    |
   | ~h1.merge(h2)~                     | creates a new hash combining h1 and h2.               |
   |                                    | If both hash have keys in common h2 keys win          |
   | ~h.select {\vert{}k,v\vert k > 1}~           | creates a sub-hash by selection                        |
   | ~h.reject {\vert{}k,v\vert k > 1}~           | creates a sub-hash by rejection                        |
   | ~select!~ and ~reject!~            | returns nil if hash does not change                   |
   | ~keep_if~ and ~delete_if~          | returns original hash even if it's unchanged            |
   | ~h.invert~                         | invert keys and values. Careful:keys must be unique   |
   | ~h.clear~                          | clears a hash                                         |
   | ~h.replace~                        | replace content of a hash                             |


*** Querying


    + ~h.has_key(1)~
    + ~h.include?(1)~
    + ~h.member?(1)~
    + ~h.has_value?(1)~
    + ~h.value?(1)~
    + ~h.empty?~
    + ~h.size~

** Ranges
   Semantics of range:
   + /Inclusion/
   + /Enumeration/

     You can remember inclusive /../ and exclusive /.../ range
     notation by thinking of a range as always reaching to the
     point represented by whatever follows the second dot.


   You can create ranges with
   + ~Range.new~
     #+BEGIN_SRC ruby :exports both
     Range.new(1, 100)
     #+END_SRC

     #+RESULTS:
     : 1..100

     #+BEGIN_SRC ruby :exports both
     Range.new(1, 100, true)
     #+END_SRC

     #+RESULTS:
     : 1...100

   + Literal syntax
     #+BEGIN_SRC ruby :exports both
     1..100
     #+END_SRC

     #+RESULTS:
     : 1..100


   Ranges have ~begin~ and ~end~ method which report their
   beginning and end point.
   They also have ~exclude_end?~ which tells you if it is an
   exclusive or inclusive range.
   They have a ~cover?~ method to know if parameter falls in
   range.
   #+BEGIN_SRC ruby :exports both
   ('a'..'z').cover?('abc')
   #+END_SRC

   #+RESULTS:
   : true

   They have an ~include?~ method which treats range as arrays.
   Therefore results differs from ~cover?~
   #+BEGIN_SRC ruby :exports both
   ('a'..'z').include?('abc')
   #+END_SRC

   #+RESULTS:
   : false

   Don't create backward range. They won't do what you think they
   do.

   #+BEGIN_SRC ruby :exports both
   (100..1).include?(50)
   #+END_SRC

   #+RESULTS:
   : false

** Sets
   A set is a unique collection of objects.

   You need to
   #+BEGIN_SRC ruby :exports both
   require 'set'
   #+END_SRC

   #+RESULTS:
   : true


   You can create sets with ~Set.new~ by providing a collection of
   objects and optionally a code block.

   #+BEGIN_SRC ruby :exports both
   require 'set'
   Set.new(['Auray','Rom', 'And']) {|name| name.upcase}
   #+END_SRC

   #+RESULTS:
   : #<Set: {"AURAY", "ROM", "AND"}>

   Use ~<<~ to add a single object to a set.
   You can also use ~add~ to add an object to a set. ~add?~
   returns nil if the set is unchanged after add operation.
   Use ~delete~ to remove an object for a set.


   You can use ~&~ to perform intersections. ~+~ and ~|~ for
   unions and ~-~ for differences.
   There is also an ~^~ exclusive or operator.

   Merging a hash into a set results in the addition of
   two-element.
   You can test for ~subset?~ and ~superset?~.

* Collections Central: Enumerable and Enumerator

  You can mix-in in ~Enumerable~ and define an ~each~ instance
  method. You will be able to call any instance method defined in
  ~Enumerable~.
  ~each~ job is to /yield/ items.

TODO find does not work
  #+BEGIN_SRC ruby :exports both :results output
    class BlueColors
      include Enumerable

      def each
        yield 'Light Blue'
        yield 'Blue'
        yield 'Dark Blue'
      end
    end

    BlueColors.new.each { |c| puts c }

#    BlueColors.find { |c| c.start_with?('B') }

  #+END_SRC

  #+RESULTS:
  : Light Blue
  : Blue
  : Dark Blue

** Enumerable
***  Queries:
   + ~include?~
   + ~all?~
   + ~any?~
   + ~one?~
   + ~none?~

   Be careful when enumerating with ranges.

   #+BEGIN_SRC ruby :exports both :results output
     begin
          puts (1.0..10.0).one? { |n| n == 5}
     rescue Exception => e
       puts e.message
     end
   #+END_SRC

   #+RESULTS:
   : can't iterate from Float


*** Search and Select

   + ~find~. You can provide a failure-handling function
     #+BEGIN_SRC ruby :results output
     failure = lambda { 11 }
     [1,2,3,4,5,6].find(failure) {|n| n> 10}
     #+END_SRC

     #+RESULTS:
     : 11

   + ~find_all~ also known as ~select~. Always returns an array.
     There's a ~select!~.
   + ~reject~. Always returns an array
   + ~grep~. Based on ~===~
   + ~group_by~. Returns a Hash

     #+BEGIN_SRC ruby :results output
     colors = %w{ red orange yellow green blue indigo violet}
     colors.group_by {|color| color.size}
     #+END_SRC

     #+RESULTS:
     | 3=> | (red) | 6=> | (orange yellow indigo violet) | 5=> | (green) | 4=> | (blue) |

   + ~partition~. Similar to ~group_by~ but split into two arrays.

*** Element operations:
   + ~first~. There is no default ~last~ because there are some
     iterations that goes forever. ~Array~ and ~Range~ have a
     ~last~ method.
   + ~take~ and ~take_while~
   + ~drop~ and ~drop_while~
   + ~min~ and ~max~. Determined by ~<=>~ (spaceship operator).
   + ~min_by~ and ~max_by~
   + ~minmax_by~ and ~maxmin_by~

*** Each relatives
   + ~reverse_each~
   + ~with_index~. ~each_with_index~ is somewhat deprecated.
     With ~with_index~ you can provide an argument that will be
     used as the first index value.
   + ~each_slice(n)~ handles each element once. ~each_cons(3)~
     takes a new grouping at each element.
   + ~cycle(n)~ to decide how many times you want to cycle through
     a collection.
   + ~inject~ similar to reduce and fold in functional languages.
     #+BEGIN_SRC ruby :exports both
     [1,2,3,4].inject(0) {|acc, n| acc + n}
     #+END_SRC

     #+RESULTS:
     : 10

   + ~map~ also available as ~collect~
     ~each~ returns its receiver
     ~map~ returns a new object

*** Sorting
   1. You need to define ~<=>~ the comparison method for the
      class. If you /mixin/ enumerable you get  all comparison
      operations (>, <, and so on).
   2. Place multiples instances of the class in a container
   3. Sort the container


   Two sorting methods for /enumerable/:
   1. ~sort~. Can take a block if you did not define ~<=>~
   2. ~sort_by~. Always take block
      #+BEGIN_SRC ruby :exports both
      ['2', '1', '3'].sort_by {|a| a.to_i }
      #+END_SRC

      #+RESULTS:
      | 1 | 2 | 3 |

** Enumerator
   ~Enumerator~ uses /Enumerable/ module to define all usual
   methods ~inject~, ~select~, ~map~ on top of its ~each~.

   After you've told how to do ~each~, ~Enumerator~ takes over and
   figures how to do the rest.

*** creating enumerators
**** with a code block
     #+BEGIN_SRC ruby
     Enumerator.new do |y|
       y << 1
       y << 2
       y << 3
     end
     #+END_SRC

     ~y~ is a /yielder/. Here we are saying, when the /Enumerator/
     get an /each/ call, please take note that your need to yield
     ~1~, then ~2~, then ~3~. ~<<~ tells ~y~ what it should yield.
     You could also write ~y.yield(1)~.

     Note you don't /yield/ from the block. The following is wrong:

     #+BEGIN_SRC ruby
     Enumerator.new do #wrong
       yield 1         #wrong
       yield 2         #wrong
       yield 3         #wrong
     end               #wrong
     #+END_SRC

**** with ~enum_for~
     In the following example ~each~ serve as a kind of front end
     to array's select.

     #+BEGIN_SRC ruby :exports both
       e = %w{ Paris Boston Tokyo }.enum_for(:select)
       e.each {|n| n.include?('a')}
     #+END_SRC

     #+RESULTS:
     | Paris |

     Most built-in iterators return an enumerator when they're
     called without a block. The following two are equivalent

     #+BEGIN_SRC ruby :exports both
     %w{ Paris Boston Tokyo }.enum_for(:select)
     %w{ Paris Boston Tokyo }.select
     #+END_SRC

     #+RESULTS:
     : #<Enumerator: ["Paris", "Boston", "Tokyo"]:select>

*** Protecting from change

    Instead of passing an original array you can pass an
    enumerator. This way your enumerator won't absorb changes.

    #+BEGIN_SRC ruby
    class Cards
      def cards
        @cards.to_enum
      end
    end
    #+END_SRC

*** Slow motion

    You can use ~next~, ~rewind~ to move in ~slow motion~.

*** Adding enumerability with an enumerator

    #+BEGIN_SRC ruby
      class Scale
        NOTES = %w{ do re mi fa sol la si do}
        def play
          NOTES.each {|note| yield note }
        end
      end

      enum = Scale.new.enum_for(:play)
    #+END_SRC

    And you can use all /enumerable/ methods on ~enum~.

*** Chaining
    Be careful when chaining. ~names.each.inject~ can be
    ~names.inject~ and ~names.map.select~ can be ~names.select~

*** Lazy enumerators
    To enumerate selectively over infinitely large collections.

    #+BEGIN_SRC ruby :exports both
    (1..Float::INFINITY).lazy.select { |n| n % 3 == 0 }.first(10)
    #+END_SRC

    #+RESULTS:
    | 3 | 6 | 9 | 12 | 15 | 18 | 21 | 24 | 27 | 30 |

* Regular Expressions
  [[http://rubular.com/][Rubular]]: online Ruby regular expression editor

  ~//~ is the regexp literal constructor

  You can use ~match~ or ~=~~ on strings. ~=~~ returns the
  numerical index of the character in the string where the match
  started. ~match~ returns an instance of the class ~MatchData~.

  You can use parenthesis to specify /captures/.

  When we do a match, ruby automatically populates a series of
  global variables which gives access to sub-matches. Those
  variables are ~$1~, ~$2~, ~$3~ and so on (~$0~ is used to store
  the name of the file from which the current program was
  initially started up).

  Witch a /MatchData/ object ~m~. ~m[0]~ gives the entire part of
  the string that matched. ~m[1]~ gives the first capture, ~m[2]~
  the second capture etc. Instead of using ~[]~ you could use
  ~captures[]~ where ~m[1] = m.captures[0]~. On your /MatchData/
  object you can use ~pre_match~ and ~post_match~ to get the
  string before and after the match. You can use ~begin(n)~ and
  ~end(n)~ to get the character index where the ~n~ math began.
  When you perform a successful match operation Ruby always set
  the global variable ~$~~ to a /MatchData/ object.

  You can specify names for your captures ~/(?<i_match_abc>abc)/~
  and then access them with ~m[:i_match_abc]~.

  ~*~ and ~+~ are /greedy/ operators. They match as many
  characters as possible.

  Look-ahead assertions. ~/\d+(?=\.)/~ match numbers before a dot.
  You have negative look-ahead assertions ~?!~ and the
  corresponding look-behind assertions ~?<=~ and ~?<!~.

  Conditional matches. ~(?(1)b|c)~ matches ~b~ if capture number 1
  is matched otherwise matches ~c~.

  Regexp modifiers. ~/abc/i~ here the ~i~ means case insensitive.
  ~m~ is for multiline (normally ~.~ does not match over lines).
  ~x~ ignores white-spaces unless escaped. It lets you add comments
  in your regular expressions

  #+BEGIN_SRC ruby
  /
  a   #this match a
  \d+ #this match a number
  /x
  #+END_SRC

  You can perform string interpolation inside a regexp. You can
  escape special reg-ex characters inside a string with
  ~Regex.escape~.

  #+BEGIN_SRC ruby
    /abc/
  #+END_SRC

  will print ~(?-mix:abc)~ which means ~m~, ~x~ and ~i~ modifiers
  are turned off for regular expression ~/abc/~.

** Common methods

   You can always use match operation as a test in find
   operations.

   + ~scan~
     Return results in an array. A cool trick is to use scan with
     a code bloc. Each match will get sent to the block and then
     discarded. Saving memory in the process.

   + ~StringScanner~ provided by ~strscan~
     You can move a /pointer/ through the scanned string and move
     using ~pos~, ~peek(n)~, ~unscan~, ~skip~, ~rest~
   + ~split~
     You can pass a second argument which limits the number of
     items returned
   + ~sub~, ~gsub~ and ~!~ versions
     ~sub~ do only one permutation.

     You can provide a second argument to access parenthetical
     captures.

     #+BEGIN_SRC ruby :exports ruby
     'aDvid'.sub(/([a-z])([A-Z])/, '\2\1')
     #+END_SRC

     #+RESULTS:
     : David

   + grep
     its uses ~===~ implicitly
     If you provide a code block you get a combined /select/map/

     #+BEGIN_SRC ruby :exports ruby
     %w{ USA UK France Germany }.grep(/[a-z]/) { |c| c.upcase }
     #+END_SRC

     #+RESULTS:
     | FRANCE | GERMANY |

* File and I/O operations
  ~IO~ handles all input and output by itself or through descendent
  like ~File~.

  ~STDERR~, ~STDIN~, and ~STDOUT~ are automatically set when the
  program starts. Ruby also gives you three global variables
  ~$stdin~, ~stdout~, ~stderr~. You are not supposed to reassign
  to the constant but you can reassign to the variable. This gives
  you a way to change the default standard I/O stream behaviors
  without losing original streams.

  ~IO~ objects iterate based on the global input record separator.
  This global input record separator is stored in ~$/~ (by default
  /newline/). It you change ~$/~ you can change the behavior of
  ~STDIN~ for example. ~$/~ determines the ~IO~ object's sense of
  each.

  You can get keyboard input with ~gets~ and ~getc~. With ~getc~
  you need to name your input stream explicitly.

  You can use block to economize the hassle to close your file objects.

** Reading files
   + ~gets~ get a line. ~nil~ after end of file. Since
     ~Enumerable~ is an ancestor you can also use ~each~ with a block
   + ~readline~ by lines. /Error/ after end of file
   + ~getc~ gets a character. ~ungetc(c)~ replace character just
     read with ~c~.
   + ~getbyte~. Depends on encoding
   + ~readchar~ and ~readbyte~ same as ~getc~ and ~getbyte~ but
     raise /Error/ on end of file.
   + ~read~ and ~readlines~
     They take care of opening and closing the file handle for you.
   + ~sysseek~, ~sysread~, ~syswrite~. Low level /I/O/.
     Un-buffered, don't mix with higher-level methods.

*** Internal pointer
    You can manipulate it with ~seek~ (moves around) and ~pos~
    (returns position) and ~rewind~ (returns to beginning of file)

    #+BEGIN_SRC ruby
    f.seek(20, IO::SEEK_SET) # to byte 20
    f.seek(15, IO::SEEK_CUR) # advance 15 byte from current position
    f.seek(-10, IO::SEEK_END) # 10 bytes before end
    #+END_SRC


** Writing to files
   + ~puts~. Returns ~nil~.
   + ~print~. Returns ~nil~.
   + ~write~. Returns the number of bytes written.

** File enumerability
   You can read a whole file into an array (with ~readline~) but it takes memory and
   it is usually a bad thing to do.
   Instead you can iterate on the file which saves memory.

   #+BEGIN_SRC ruby
     File.readlines('myfile.txt').inject(0) {|total, line| #do stuff} # bad
     File.open('myfile.text').inject(0) {|total, line| #do stuff} # good
   #+END_SRC

** Querying

   Two closely related module and class: ~File::Stat and
   FileTest~. The methods available in ~File~ and ~FileTest~ are
   mostly aliases.

   + size
     ~File.size('myfile.txt')~, ~FileTest.size('myfile.txt')~ and ~FIle::Stat.new('myfile').size~
   + ~FileTest.exist?~
   + ~FileTest.directory?~
   + ~FileTest.file?~
   + ~FileTest.symlink?~
   + ~FileTest.readable?~, ~FileTest.writable?~,
     ~FileTest.executable?~


   ~File::Stat~ objects have attributes corresponding to the
   standard C library.

   ~Kernel~ has a ~test~ method. It can test for files and
   directories.

   #+BEGIN_SRC ruby
   test ?e, '/tmp' #exists?
   #+END_SRC

   Other character to test with are ~?d~ for directory, ~?f~ for
   regular file, ~?z~ for zero length file.

** Directory manipulation
   With the ~Dir~ class.

   + ~Dir.entries~
   + Globing with ~Dir[]~ or ~Dir.glob~. With ~glob~ you can give
     flag arguments like ~File::FNM_CASEFOLD~, ~File::FNM_DOTMATCH~
   + ~mkdir~, ~chdir~, ~rmdir~

** ~FileUtils~

   + ~FileUtils.rm_rf~
   + ~FileUtils.ln_s~
   + ~FileUtils.cp~
   + ~FileUtils.mkdir~
   + ~FileUtils.mv~
   + ~FileUtils.rm~
   + ~FileUtils.rm_rf~

   Those methods can be used with ~FileUtils::DryRun~ to see the
   output of the equivalent unix method call.

   You can use ~FileUtils::NoWrite~ to make sure you don't
   accidentally delete, overwrite or move files.

** ~Pathname~

   + ~basename~
   + ~dirname~
   + ~extname~
   + ~ascend~ lets you walk up the directory structure with a code
     block
     #+BEGIN_SRC ruby :exports ruby :results output
       require 'pathname'
       Pathname.new(File.expand_path('~')).ascend {|x| puts x }
     #+END_SRC

     #+RESULTS:
     : /Users/aurelienbottazzini
     : /Users
     : /

** ~StringIO~
   treats string like IO objects. You can see trough them, rewind etc.

** ~Tempfile~
   Useful to run tests

   #+BEGIN_SRC ruby
   Tempfile.new('tmp')
   #+END_SRC

** ~open-uri~
   Standard /HTTP/ and /HTTPS/ library.

   #+BEGIN_SRC ruby :exports both
   require 'open-uri'
   webpage = open('http://aurelienbottazini.com')
   webpage.gets
   #+END_SRC

   #+RESULTS:
   : <!DOCTYPE html>

* Object individuation
   Every object has two classes.
   + The class of which it's an instance
   + Its singleton class


   Singleton classes are anonymous, they appear automatically
   without being given a name.

   To get inside the singleton class of an object you use a
   special notation.

   #+BEGIN_SRC ruby
   class << object
     # methods and constants definitions
   end
   #+END_SRC

   ~<< object~ means the anonymous, singleton class of object.

   There is a difference when you add a method with
   ~obj.some_method~ and ~class obj; def some_method~: constants.
   When you have a top level constants, you can also add a
   singleton constant with the same name. ~obj.some_method~ can
   use the top level one. ~class obj; def some_method~ will use
   the singleton one.

   you can think ~class~ as either willing to accept a /constant/
   or a  ~<< object~ expression.

   You can define class methods with ~<<~

   #+BEGIN_SRC ruby
   class Ticket
     class << self #inside the body, same as class << Ticket
       def class_method
       end
     end
   end
   #+END_SRC

   Outside the body of a class you can define the same method with

   #+BEGIN_SRC ruby
   class << Ticket
     def class_method
     end
   end
   #+END_SRC


   ~ancestors~ is a useful method to look-up the class hierarchy

   #+BEGIN_SRC ruby :exports both :results output
     module M
     end
     class C
     end
     c = C.new
     class << c
       include M
       p ancestors
     end
   #+END_SRC

   #+RESULTS:
   : [#<Class:#<C:0x007fc7f095a370>>, M, C, Object, Kernel, BasicObject]

   You can refer to the singleton class of an object with the
   ~singleton_class~ method.

   #+BEGIN_SRC ruby :exports both :results output
     puts 'hello'.singleton_class.ancestors
   #+END_SRC

   #+RESULTS:
   : #<Class:#<String:0x007ff643816e10>>
   : String
   : Comparable
   : Object
   : Kernel
   : BasicObject

   An alias is a synonym for a method name. By convention when we
   create an alias with use ~__old_method_name__~ to make an alias
   for ~method_name~.
   To make an alias you can use ~alias~ or ~alias_method~. The
   difference is that ~alias_method~ takes objects (/symbols/ or
   /strings) instead of bare method names.

   #+BEGIN_SRC ruby
   alias __old_method method # no comma
   alias_method :__old_method, :method
   #+END_SRC

   The ~tap~ method execute a code block (yielding the receiver to
   the block) and returns the receiver.

   #+BEGIN_SRC ruby :exports both :results output
     puts 'hello'.tap {|s| puts s.upcase }.reverse
   #+END_SRC

   #+RESULTS:
   : HELLO
   : olleh


** Additive changes
   Danger: two programmer add a method with the same name.

** Pass-through overrides
   The original version of the method end up being called

   #+BEGIN_SRC ruby :exports both :results output
     class String
       alias __old_reverse__ reverse

       def reverse
         puts 'reversing a string!'
         __old_reverse__
       end
     end
     puts 'hello'.reverse
   #+END_SRC

   #+RESULTS:
   : reversing a string!
   : olleh

** Additive/pass-through hybrids
   same name, calls the old version and adds something to the
   interface. It offers a superset of the functionality of the
   original method.

   For example /Active Support/ allows ~Time.now.to_s~ to take an
   argument to specify a formatting like ~Time.now.to_s(:db)~

** Extend
   Safest way to add functionality on a strictly per-object basis.

   You can mix-in modules with /extend/ in objects respective
   singleton class on directly on class.

   #+BEGIN_SRC ruby :exports both :results output
     module Secretive
       def name
         'not available'
       end
     end

     class Person
       attr_accessor :name
     end

     david = Person.new
     david.name = 'David'
     david.extend(Secretive)
     puts david.name
   #+END_SRC

   #+RESULTS:
   : not available

   #+BEGIN_SRC ruby
   module Makers
     def makes
       %w{ Honda Ford Toyota Audi }
     end
   end
   class Car
     extend Makers
   end
   #+END_SRC

** Refinements
   New in Ruby 2.0. The idea is to make a temporary, limited-scope
   change to a class.

   #+BEGIN_SRC ruby :exports both :results output
     module Shout
       refine String do
         def shout
           self.upcase + '!!!'
         end
       end
     end

     class Person
       attr_accessor :name

       using Shout

       def announce
         puts "I'm #{name.shout}"
       end
     end

     auray = Person.new
     auray.name = 'Auray'
     puts auray.announce
   #+END_SRC

   #+RESULTS:
   : I'm AURAY!!!
   :

   If you use ~using~ outside of a class of module, the
   refinements persists to the end of the file.

** Basic Object

   For any object: ~obj.class.ancestors.last == BasicObject~.

   ~BasicObject~ allows you to create objects that do nothing.
   Which means you can teach them everything without worrying about
   clashing with existing methods.

* Callable and runnable object

** Procs
   #+BEGIN_SRC ruby
   pr = Proc.new { puts 'Inside a proc\'s block' }
   pr.call
   #+END_SRC

   The ~proc~ method takes a block an returns a /Proc/ object. So
   the following two are equivalent.

   #+BEGIN_SRC ruby
   proc { puts 'Hi!'}
   Proc.new { puts 'hi!' }
   #+END_SRC

   A /proc/ can serve in place of a code block in a method call

   #+BEGIN_SRC ruby
   p = proc {|x| puts x.upcase }
   %w{ David Black }.each(&p)
   #+END_SRC

   A ruby code block is not an object. A code block is part of the
   syntax of the method call. A code block is a syntactic construct
   and code block aren't method arguments.

   Consider:

   #+BEGIN_SRC ruby :exports both :results output
   def capture_block(&block)
     block.call
   end
   capture_block { puts 'inside a block' }
   #+END_SRC

   #+RESULTS:
   : inside a block

   Without the special flag ~&~, ruby has no way of knowing that
   you want to stop binding parameters and instead perform a
   block-to-proc conversion. ~&~ also appears the other way around.
   i.e use a proc instead of a code block.

   #+BEGIN_SRC ruby :exports both :results output
     def capture_block(&block)
       block.call
     end

     p = Proc.new { puts 'inside a block' }
     capture_block(&p)
   #+END_SRC

   #+RESULTS:
   : inside a block

   the ~&~ in ~&p~ is a wrapper around the method ~to_proc~. Here
   ~&~ triggers a call to ~p~'s ~to_proc~ method and it tells ruby
   that the resulting ~Proc~ object is serving as a code block
   stand-in.

   You can define ~to_proc~ in any class or for any object and the
   ~&~ technique will then work on affected objects.

   You can use this built in method ~&~ in play for conciseness.

   #+BEGIN_SRC ruby :exports both
   %w{ ruby haskell}.map(&:capitalize)
   #+END_SRC

   #+RESULTS:
   | Ruby | Haskell |

   Here ~:capitalize~ is interpreted as a message to be sent to
   each element of the array in turn.

   If we try to implement it ourselves:
   #+BEGIN_SRC ruby
   class Symbol
     def to_proc
       Proc.new {|obj| obj.send(self)}
     end
   end
   #+END_SRC

   The method returns a ~Proc~ object that takes one argument and
   sends ~self~ to that object.

   One of the most important thing about proc is there service
   as closure.

   When you construct the code block for a call to ~Proc.new~, the
   local variables are still in scope.

   #+BEGIN_SRC ruby :exports both
   @a_values = []
   def calling_proc(pr)
     a = 'inside calling_proc'
     @a_values << a
     pr.call
   end
   a = 'outside calling_proc'
   pr = Proc.new { @a_values << a }
   calling_proc(pr)
   #+END_SRC

   #+RESULTS:
   | inside calling_proc | outside calling_proc |

   ~Proc~ doesn't care about the number of arguments. Without arguments
   it's single argument is set to ~nil~. With more than one
   argument the remaining ones are discarded.

   ~lambda~ returns a ~Proc~ object. There is no ~lambda~ class.
   ~lambda is like a special ~Proc~.

   ~return~ inside a ~lambda~ triggers an exit from the body of the
   ~lambda~. ~return~ inside a ~proc~ triggers a return from the
   method in which the ~proc~ is being executed.

   ~lambda~ proc raise an error when called with the wrong number
   of arguments.

   ~->~ also know as stabby lambda is a ~lambda~ constructor.

   #+BEGIN_SRC ruby :exports both
   mult = ->(x,y) { x * y }
   #+END_SRC

   #+RESULTS:
   : #<Proc:0x007fa62a815d58@-:3 (lambda)>

   You can use ~[]~ which is a synonym for ~call~ to call callable
   objects

   #+BEGIN_SRC ruby :exports both
   mult = ->(x,y) { x * y }
   twelve = mult[3,4]
   #+END_SRC

   #+RESULTS:
   : 12

** Methods as objects

   You can grab a method with the ~method~ method.

   #+BEGIN_SRC ruby :exports both
   m = 'hello'.method(:upcase)
   m.call
   #+END_SRC

   #+RESULTS:
   : HELLO

   You can grab an instance method with ~instance_method~

   You can ~unbind~ a method and ~bind~ it again as long as the
   two objects are of the same class or subclass.

** Eval

   ~Binding~ encapsulates the local variable bindings. There is
   also a top-level method ~binding~ which returns whatever the
   binding is.
   The most common use of ~Binding~ in the second argument of
   ~eval~ to provide a given binding to ~eval~.

   #+BEGIN_SRC ruby :exports both :results output
   def use_a_binding(b)
     eval("puts str", b)
   end

   str = 'I am a string'
   use_a_binding(binding)
   #+END_SRC

   #+RESULTS:
   : I am a string


*** ~instance_eval~

    Evaluate string or block of code changing ~self~ to be the
    receiver of ~instance_eval~.

    Useful to break in another object's private data.

    #+BEGIN_SRC ruby
    c.instance_eval { puts @x }
    #+END_SRC

    ~instance_exec~ is like ~instance_eval~ but it takes a second
    argument it can pass as an argument to the code block

    You can use ~instance_eval~ to allow simplified assignment

TODO does not work
    #+BEGIN_SRC ruby :exports both :results output
      class Person
        def initialize(&block)
          instance_eval(&block)
        end

        def name(name=nil)
          @name ||= nil
        end

        def age(age=nil)
          @age ||= age
        end
      end

      p = Person.new do
        name 'David'
        age 55
      end

      puts p.name
    #+END_SRC

    #+RESULTS:
    :

*** ~class_eval~

    It puts you inside a class-definition body

    #+BEGIN_SRC ruby
    c = Class.new
    c.class_eval do
      def some_method
      end
    end
    #+END_SRC

*** ~define_method~

    useful to bring an outer scope variable  into an instance
    method

    #+BEGIN_SRC ruby
    var = 'hello'
    C.class_eval { def talk; puts var; end }
    #+END_SRC

    does not work because ~def~ creates a new scope.

    #+BEGIN_SRC ruby
    var = 'hello'
    C.class_eval {define_method('talk') { puts var }}
    #+END_SRC

    works because the block keeps the scope.

** Threads

   #+BEGIN_SRC ruby :exports both :results output
   t = Thread.new do
     puts 'starting'
     sleep 1
     puts 'end'
   end
   puts 'outside thread'
   t.join
   #+END_SRC

   #+RESULTS:
   : outside thread
   : starting
   : end

   Don't forget to use ~join~ to allow the thread to finish
   executing (if it takes more time than the remaining of the
   program).

   you can ~kill~ or ~exit~ or ~terminate~ a thread (all synonyms).

   You can ~stop~ and ~wakeup~ a ~Thread~. You check its ~status?~,
   if it is ~stop?~ and ~alive?~.

   Threads use code blocks and code blocks can see the variables
   already created in their local scope. However some globals are
   thread-local globals like ~$1~, ~$2~ and so on.

   Threads also have their own variable stash. It let them
   associate symbols or strings with values.

   #+BEGIN_SRC ruby :exports both :results output
   t = Thread.new do
     Thread.current[:message]  = 'Hello'
   end
   t.join
   p t.keys
   puts t[:message]
   #+END_SRC

   #+RESULTS:
   : [:message]
   : Hello

*** example chat server using sockets and threads

    #+BEGIN_SRC ruby
    require 'socket'
    def welcome(chatter)
      chatter.print 'Welcome! enter your name:'
      chatter.readline.chomp
    end

    def broadcast(message, chatters)
      chatters.each do |chatter|
        chatter.puts message
      end
    end

    s = TCPServer.new(3939)
    chatters = []

    while(chatter = s.accept)
      Thread.new(chatter) do |c|
        name = welcome(chatter)
        broadcast("#{name} has joined", chatters)
        chatters << chatter
        begin
          loop do
            line = c. readline
            broadcast("#{name}: #{line}", chatters)
          end
        rescue EOFError
          c.close
          chatters.delete(c)
          broadcast("#{name} has left", chatters)
        end
      end
    end
    #+END_SRC

** Fibers
   Fibers are like re-entrant code blocks. They can yield back and
   forth to their calling context multiple times.

   #+BEGIN_SRC ruby :exports both :results output
   f = Fiber.new do
     puts 'hi'
     Fiber.yield
     puts 'hi again'
     Fiber.yield
     puts 'last hi'
   end
   f.resume
   f.resume
   f.resume
   #+END_SRC

   #+RESULTS:
   : hi
   : hi again
   : last hi

** system commands

   With back-ticks ~``~ (returns the output and string interpolation) or ~system~.

   When you use ~system~ and ~``~, the global variable ~$?~ is set to a
   ~Process::Status~, it contains the process ID and its exit
   status and it is thread-local

   A call to nonexistent system method with back-ticks raise a fatal error.
   You can also use ~%x{}~. It returns the output and allow string
   interpolation.

** ~open~ and ~open3~

   #+BEGIN_SRC ruby
   d = open('|cat', 'w+')
   d.puts 'Hi'
   d.gets
   d.close
   #+END_SRC

   We talk to system command /cat/. The ~|~ indicates we want to
   talk to a program and not open a file.

   #+BEGIN_SRC ruby
   require 'open3'
   stdin, stdout, stderr = Open3.popen3('cat')
   stdin.puts('Hi.\nBye.')
   stdout.gets
   stdout.gets
   #+END_SRC

* Callbacks, hooks and run-time introspection

  /callbacks/ and /hooks are used for meta-programming. They
  activate on /events/.

  An event can be something like:

  + A nonexistent method called on an object
  + An object being extended by a module
  + A class being sub-classed
  + An instance method added to a class
  + A nonexistent module called on an object


** ~method_missing~

   #+BEGIN_SRC ruby
   def method_missing(m, *args, &block)
     raise NameError, "what do you mean by #{m}"
   end
   #+END_SRC

   We redefined ~method_missing~ at the top level. Making it a
   private instance of method ~Object~. Thus it is available for
   all objects except instances of ~BasicObject~.

   ~method_missing~ and ~respond_to?~ don't play well together. If
   you create methods dynamically inside ~method_missing~ but
   ~respond_to?~ will still say they don't exist. To go around
   that problem you can implement ~respond_to_missing?~

   Here is an example
   #+BEGIN_SRC ruby
   def method_missing(m, *args, &block)
     if /set_(.)/.match(m)
       #respond to message
     end
   end

   def respond_to_missing?(m, include_private = false)
     /set_/.match(m) || super
   end
   #+END_SRC

** prepend and include
   You can define special methods called ~included~ and ~prepended~

   #+BEGIN_SRC ruby :exports both :results output
     module M
       def self.included(c)
         puts "mixed into #{c}"
       end
     end

     class C
       include M
     end
   #+END_SRC

   #+RESULTS:
   : mixed into C

   You can even add class methods with this technique

   #+BEGIN_SRC ruby
   module M
     def self.included(c)
       def c.a_class_method
       end
     end

     def an_inst_method
     end
   end
   #+END_SRC

** extended

   #+BEGIN_SRC ruby
   module M
     def self.extended(obj)
     end
   end
   #+END_SRC

** intercepting inheritance

   With ~inherited~
   #+BEGIN_SRC ruby :exports both :results output
     class C
       def self.inherited(subclass)
         puts "#{self} inherited from #{subclass}"
       end
     end
     class D < C # triggers inherited
     end
     class E < D # triggers inherited
     end

   #+END_SRC

   #+RESULTS:
   : C inherited from D
   : D inherited from E

   ~inherited~ is a class method so it defines an ~inherited~
   cascade. ~inherited~ does not work on singleton class.

** ~const_missing~

   #+BEGIN_SRC ruby :exports both :results output
     class C
       def self.const_missing(const)
         const_set(const, 1)
       end
     end

     puts C::UNKNOWN
   #+END_SRC

   #+RESULTS:
   : 1

** ~method_added~

   #+BEGIN_SRC ruby
   class C
     def self.method_added(m)
     end
   end
   #+END_SRC


** listing methods
   With ~methods~ you can list the non-private methods of the
   object itself. You don't get the methods from /mix-ins/ for
   examples. It can take an argument, if you set it to false you
   won't get methods from ancestors.

   ~private_methods~ list private methods
   ~protected_methods~ list protected methods
   ~singleton_methods~ list singleton methods

   You can do ~methods.grep(/methods/).sort~ to find a detailing
   listing of your possibilities.

   #+BEGIN_SRC ruby :exports both :results output
     puts Object.methods.grep(/methods/).sort
   #+END_SRC

   #+RESULTS:
   : instance_methods
   : methods
   : private_instance_methods
   : private_methods
   : protected_instance_methods
   : protected_methods
   : public_instance_methods
   : public_methods
   : singleton_methods

** instropection

   + ~local_variables~ list local variables. Inside irb you will
     see ~[:_]~. It is a special irb variable. It represents the
     value of the last expression evaluated by irb.

   + ~global_variables~ list global variables
   + ~instance_variables~ list instance variables
   + ~caller~ provides an array of strings representing the
     stack-trace

     #+BEGIN_SRC ruby :exports both :results output
       def z
         puts caller
       end
       z
     #+END_SRC

     #+RESULTS:
     : -:4:in `<main>'

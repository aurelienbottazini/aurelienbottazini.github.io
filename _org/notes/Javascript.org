#+PROPERTY: header-args :results output
#+BEGIN_HTML
---
layout: notes
---
#+END_HTML
#+TOC: headlines 4

* Execution Context

The execution context is divided in 2 distinct phase.
1. Creation
  Sets up memory space for variables (set to undefined) and functions.
   This is what is the cause of *Hoisting*
2. Execution
  This is were variable assignments take place.

#+begin_src js
  b();
  var a = 'Hello world';

  function b() {
      console.log('called b');
  }
#+end_src

#+RESULTS:
: called b

 Each execution context has a reference to the outer environment
 defined by the lexical environment.

** Global execution context

   The global execution context creates two things for us.

   1. The global object and
   2. A special variable ~this~. In case of browsers the global object is
      window. At the global level the global object is ~this~.

   Global just means not inside a function.

* Scope
  With ES2015/ES6  we have ~let~ and ~const~ available for block scoping.
  Javascript has function scoping even without ES6.

* Undefined
  ~undefined~ is different from _not defined_. ~undefined~ is a
  special value meaning the variable has not been set.
* Debugging
 In Chrome and Firefox $0 is a reference to the selected DOM node in the elements
 tab, so by doing this you get the selected DOM node scope printed
 out in the console

 You should learn your console tools. If you are using chrome, Take
 10 minutes and read:
 https://developer.chrome.com/devtools/docs/console

* Object
  An object in javascript is a collection of name value pairs and a
  value can be another object containing other value pairs.

  Objects can have properties and methods.
  Properties can be primitive properties or methods.
  An object has references to where his properties and methods are
  sitting in memory.

  JS Frameworks commonly use Objects to setup namespaces.

#+begin_src js
  let object = {
      property: 'my first property',
      insider_object: {
          hello: 'world'
      }
  }

  console.log(object["property"]);
  console.log(object.property);
#+end_src

#+RESULTS:
: my first property
: my first property

** Destructuring

#+begin_src js
  var people = [
      {
          "firstName": "Clinton",
          "lastName": "Ruiz",
          "phone": "1-403-985-0449",
          "email": "pharetra@facilisislorem.org",
          "address": "Ap #829-3443 Nec St."
      },
      {
          "firstName": "Skyler",
          "lastName": "Carroll",
          "phone": "1-429-754-5027",
          "email": "Cras.vehicula.alique@diamProin.ca",
          "address": "P.O. Box 171, 1135 Feugiat St."
      },
  ]

  people.forEach(({firstName}) => console.log(firstName))


  var [,Skyler] = people;

  function logEmail({email}){
      console.log(email);
  }

  logEmail(Skyler);
#+end_src

#+RESULTS:
: Clinton
: Skyler
: Cras.vehicula.alique@diamProin.ca

* Operators
   Operators are infix functions

** Associativity
   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

   Coercion and associativity can lead to unexpected “bugs”

#+begin_src js
  if (3 < 2 < 1) {
    console.log(true);
  }
#+end_src

#+RESULTS:
: true

   ~===~ and ~==!~ do no try to coerce

* Equality operators
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness

* Synchronous
  JS is synchronous, there is an event queue responding to events, for
  example a click. JS looks at the event queue when the execution stack
  is empty.

  The browser is asynchrounously putting things in the event queue. The
  JS engine is processing things synchronously.

* 6 Primitive types

  - Undefined. Lacks of existence. Don't use this type
  - null
  - Boolean
  - Number - floating point
  - String
  - Symbol in es6

* Default values
  When calling a function without a parameter, Javascript creates a new
  execution context and set this new / missing parameter variable to undefined.

#+begin_src js
  let name = name || 'default value'; // be careful about 0
#+end_src

  Frameworks use the default value ~||~ trick to see if other librairies
  are not colliding and to decide to load or not.
* JSON
  Stands for Javascript Object Notation.
  Inspired by javascript object notation but not exactly the same!

#+begin_src js
  var objectLiteral = {
    firstname: 'Aurélien',
    isAProgrammer: true
  }

  console.log(JSON.stringify(objectLiteral));
  var jsonValue = JSON.parse('{ "firstName": "Aurélien", "isAProgrammer": true }');
  console.log(jsonValue);
#+end_src

#+RESULTS:
: {"firstname":"Aurélien","isAProgrammer":true}
: { firstName: 'Aurélien', isAProgrammer: true }

* Functions
  Functions are special type of objects.

  Functions has special properties.
  1. Name. Optional. A function can be anonymous
  2. Code. This code being invocable with ~()~
  3. arguments. You can use ~arguments~
  4. you can also use ~...other~, the spread operator, to wrap remaining
     arguments.
  5. prototype. Only used when we use ~new~ -> confusing name. This is
     not the prototype of the function. It is the prototype of any
     object created if we are using the function as a function constructor.

  You can add properties to functions as you would do with other
  objects.

#+begin_src js
  function greet() {
      console.log('hi');
  }

  greet.language = 'english';
  console.log(greet.language);
#+end_src

#+RESULTS:
: english

  Function statement & expression
#+begin_src js
  // statement
  function greet() {
    console.log('hi');
  }
  greet();

  // expression
  var anonymousGreet = function() {
    console.log('hi');
  }
  anonymousGreet();
#+end_src

#+RESULTS:
: hi
: hi

  You can pass functions as variables: functional programming.

  Thanks to hoisting, even when you don't provide all necessary
  agruments to a function the arguments have memory space allocated to
  them and initialized to ~undefined~.
** Immediatly Invoked Function Expression

   We enclose the function in parenthesis to /trick/ the js engine. It
   makes the function an expression and not a statement. It allows us to
   call it immediatly.

   With IIFE you create a new execution context and variables do not
   leak into the global object.

#+begin_src js
  var greeting = 'bonjour';

  (function(name){
    var greeting = 'hi ';
    console.log(greeting + name);
  }('Aurélien')); // you also do })('Aurélien'). Just a matter of style.

  console.log(greeting); // bonjour
#+end_src

#+RESULTS:
: hi Aurélien
: bonjour

** Call, apply, and bind

   All functions objects have access to three functions, ~call()~,
   ~apply()~, and ~bind()~

#+begin_src js
  var person = {
      firstname: 'John',
      lastname: 'Doe',
      getFullName: function() {
          var fullname = this.firstname + ' ' + this.lastname;
          return fullname;
      }
  }

  var logName = function(lang1, lang2) {
      console.log('Logged ' + this.getFullName());
      console.log('Arguments: ' + lang1 + ' ' + lang2);
  }

  var logPersonName = logName.bind(person, 'en'); // creates a copy of the
                                            // function, binding person to
                                            // ~this~ for the new
                                            // function, also sets up
                                            // first parameter to ~en~.
                                            // This does not call the
                                            // function

  logName.call(person, 'en', 'fr'); // calls the function, first arguments
                                    // is what ~this~ should refer to.
                                    // Rest are parameters for the
                                    // function

  logName.apply(person, ['en', 'es']); // like call but wants an array of
                                       // parameters
#+end_src

#+RESULTS:
: Logged John Doe
: Arguments: en fr
: Logged John Doe
: Arguments: en es

** Functional Programming

#+begin_src js
  var checkPastLimit = function(limiter, item) {
    return item > limiter;
  }
  mapForEach(arr1, checkPastLimit.bind(this, 1));

  var checkPastLimitSimplified = function(limiter) {
    return function(limiter, item) {
      return item > limiter;
    }.bind(this, limiter);
  }
  mapForEach(arr1, checkPastLimitSimplified(1));
#+end_src


** Arguments

#+begin_src js
  function hello(...keys) {
    console.log(arguments);
    console.log(keys);

    arguments[0] = 'hello';
    arguments[1] = 'bye'
    keys[0] = 'bonjour';
    keys[1] = 'au revoir';
    console.log(arguments);
    console.log(keys);
  }

  hello(1, 2);
#+end_src

#+RESULTS:
: { '0': 1, '1': 2 }
: [ 1, 2 ]
: { '0': 'hello', '1': 'bye' }
: [ 'bonjour', 'au revoir' ]

* Value vs Reference

  If ~a~ is a primitive type, it is passed by value. If ~a~ is an
  object, remember functions are also objects, it is passed by
  reference.

#+begin_src js
  a = 3;
  b = a; // b and a point to different spots in memory.
  a = 4; // a = 4 and b = 3;

  c = { greeting: 'Hi' };
  d = c; // d and c point to the same spot in memory
  c.greeting = 'hello'; // d.greeting === 'hello'

  c = { greeting: 'Bonjour' }; // Special case, we are using equal to
                               // assign a new object literal
#+end_src

* This

#+begin_src js
  console.log(this); // Window object

  function a() {
    //console.log(this)
    this.newvariable = 'hello';
  }
  a(); // Window object

  var b = function() {
   console.log(this);
  }
  //b(); // Window object

  console.log(newvariable); // hello

  var c = {
    name: 'The c object',
    log: function() {
      var self = this; // Objects, so by reference, so pointing to same
                       // object. For clarity, it is better to use self everywhere.

      this.name = 'new C name';
      console.log(this); // c.name === 'new C name'
      var setname = function(newname) {
        this.name = newname; // Points to the global object
        self.name = newname; // points to c.name. Correctly update the
                             // name
      }
      var es6StyleSetname = newname => {
        this.name = newname; // points to c.name
      }
      setname('Updated C object again'); // c.name === new C name
    }
  }

  c.log();
  console.log(c.name);
  console.log(this.name);
#+end_src

#+RESULTS:

* Array
  They can contain any type

#+begin_src js
  var arr = [ 1, ,false, function() { console.log('hi') }];
  arr[3]();
#+end_src

#+RESULTS:
: hi

* Closure
  Closures are particularly useful with function factories.

#+begin_src js
  function greet(whattosay) {
    return function(name) {
      console.log(whattosay + ' ' + name);
    }
  }

  greet('hello')('Aurélien'); // like connect function for redux
  var sayHi = greet('Hi'); // we create a closure. Execution context of
                           // greet is gone but sayHi still has access to
  // the memory space setup for that execution context = closure
  sayHi('Aurélien');
#+end_src

#+RESULTS:
: hello Aurélien
: Hi Aurélien

#+begin_src js
  function buildFunctions() {
    var arr = [];
    for(var i = 0; i < 3; i++) { // i is not scoped to the block
      arr.push(function() { // function expression, we are not executing
          // the function
        let j = i; // j is scoped to block
        console.log(i);

        console.log(j);
      });

    }

    return arr;
  }

  var fs = buildFunctions(); // at the and of buildFunctions execution
                             // context i = 3

  fs[0](); // 3, 1
  // fs[1](); // 3, 2
  // fs[2](); // 3, 3
#+end_src

  A solution in es5 is to use IIFE to our advantage.

#+begin_src js
  for(var i = 0; i < 3; i++) {
    arr.push(
      (function(j) {
         return function() {
           console.log(j);
         }
      }(i)) // using IIFE and close to keep the value of i in an
            // execution context.
    )
  }
#+end_src

* Prototypal inheritance
  All objects have a prototype property. This prototype property is used
  to search for properties not present on our object.

  You can access the prototype property directly with ~__proto__~. But
  you should never use it in production code as it is slow.

#+begin_src js
  var person = {
      firstname: 'Default',
      lastname: 'Default',
      getFullName: function() {
          return this.firstname + ' ' + this.lastname; // ! this points to
          // what is calling the function
      }
  }

  var john = {
      firstname: 'John',
      lastname: 'Doe'
  }

  //slow don't do this
  john.__proto__ = person;
  console.log(john.getFullName()); // John Doe
#+end_src

    Only the base object does not have a prototype. Eventually when you
    go through the prototype chain you reach the base object.
* new

#+begin_src js
  // as a convention always use a capital letter when you define a function constructor
  function Person(firstname, lastname) {
      this.firstname = firstname;
      this.lastname = lastname;
// don't return anything if you want to use the function as function constructor
// As long as it does not return anything it will return the object created by `new`
  }

  // better than adding inside function Person because this way it will
  // not take memory space. BUT only used with `new` function constructor
  Person.prototype.getFullName = function() {
      return this.firstname + ' ' + this.lastname;
  }

  // when we use new an empty object is created and THEN it calls the function Person.
  // The this variable points to the empty object created by new.
  var john = new Person('John', 'Doe');
  // if you forget new it will return undefined -> bug hard to track
  var jane = new Person('Jane', 'Doe');

  // added to all objects created with `new Person`
  Person.prototype.fetFormalFullName = function() {
      return this.lastname + ', ' + this.firstname;
  }
#+end_src

  There are built in function constructors. ~new Number~, ~new String~.
  They are creating Objects, not primitives. Don't use them, they can
  introduce hard to track bugs in your code.

#+begin_src js
  3 == Number(3) // true
  3 === Number(3) // false

  String.prototype.isLengthGreaterThan = function(limiter) {
      return this.length > limit;
  }

  // works because "John" is converted by JS to an object
  console.log("John".isLengthGreaterThan(3));

  Number.prototype.isPositive = function() {
      return this > 0;
  }

  // exception
  console.log(3.isPositive());

  // works
  console.log((new Number(3)).isPositive());

#+end_src
* for in

  Don't use for in with arrays. Array values are stored as properties.
  So if you add a new property to the Array prototype it is also going
  to be listed by for in

#+begin_src js
  Array.prototype.myCustomFeature = 'cool!';

  // calls new Array
  var arr = ['John', 'Jane', 'Jim'];

  for(var prop in arr) {
      console.log(prop + ': ' + arr[prop]);
  }
#+end_src

#+RESULTS:
: 0: John
: 1: Jane
: 2: Jim
: myCustomFeature: cool!

* Object.create

#+begin_src js
  var person = {
      firstname: "Default",
      lastname: "Default",
      greet: function() {
          return 'Hi ' + this.firstname;
      }
  }

  // sets __proto__ to person
  // object is empty
  // pure prototypal inheritance
  var john = Object.create(person);

  // we override what we want.
  john.firstname = 'John';
  john.lastname = 'Doe';
  console.log(john);
#+end_src
* ES6 classes

  class are also objets. You need to use new.
  Different from classes in Java.

  You set the prototype with ~extends~.
  ~super~ call the method from the prototype.
* What something is
  ~typeof~
  ~instanceof~ goes through the prototype chain

  Known bug
#+begin_src js
  console.log(typeof null === 'object');
#+end_src

#+RESULTS:
: true
: undefined

* Strict mode
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode
* Tricks

#+begin_src js
  ;(function(…
#+end_src
  ~;~ is to ensure, in case we are using other external js code that it
  properly finishes with a ~;~
* const

  To declare a constant. The check is on the reference so

  #+begin_src js
    const pi = '3.14';
    pi = 9; // will not reassign
    console.log(pi);
  #+end_src

  #+RESULTS:

  #+begin_src js
    const data = { hello: 'hi' };
    data.hello = 'bonjour'; // will change hello prop
    console.log(data);
  #+end_src

  #+RESULTS:
  : { hello: 'bonjour' }
  : undefined

* generators

 #+begin_src js
  function* greet(){
    console.log(`You called 'next()'`);
    yield "hello";
  }
  var greeter = greet();
  console.log(greeter);
  var next = greeter.next();
  console.log(next);
  var done = greeter.next();
  console.log(done);
 #+end_src

 #+RESULTS:
 : GeneratorFunctionPrototype { _invoke: [Function: invoke] }
 : You called 'next()'
 : { value: 'hello', done: false }
 : { value: undefined, done: true }
 : undefined


  Passing an argument to next define the *previous* return value of yield.
#+begin_src js
   'use strict';
   function* greet(){
      let friendly = yield "How";
      friendly = yield friendly + "are";
      yield friendly + "you?";
  }

  var greeter = greet();
  console.log(greeter.next("first").value); // first is lost because it is impossible to pass a return value
                                            // for the first yield. Does not make any sense it was the first one!
  console.log(greeter.next(" the heck ").value); // friendly for second yield is equal to `the heck`
  console.log(greeter.next(" silly ol'").value); // friendly for last yield is equal to silly ol

#+end_src

#+RESULTS:
: How
:  the heck are
:  silly ol'you?
: undefined

  Yield makes it possible to deal with infinite loops.
#+begin_src js
  function* graph(){
      var x = 0;
      var y = 0;
      while(true){
          yield {x:x, y:y}
          x += 2;
          y += 1;
      }
  }


  var graphGenerator = graph();
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);
  console.log(graphGenerator.next().value);

#+end_src

#+RESULTS:
: { x: 0, y: 0 }
: { x: 2, y: 1 }
: { x: 4, y: 2 }
: { x: 6, y: 3 }
: { x: 8, y: 4 }
: { x: 10, y: 5 }
: { x: 12, y: 6 }
: { x: 14, y: 7 }
: undefined

* ES6 strings

  You can interpolate and create multiline strings
  #+begin_src js :cmd "org-babel-node --presets es2015"

    let salutation = "Hello";
    let place = "planet";
    let greeting = `

    ${salutation},
      You
        Crazy        ${place}

        How
      Are
          You


    `;
    console.log(greeting);
  #+end_src

  #+RESULTS:
  #+begin_example


  Hello,
    You
      Crazy        planet

      How
    Are
        You



  undefined
#+end_example

  You can create dynamic strings
#+begin_src js

  function tag(strings, ...values){
      if(values[0] < 20) {
          values[1] = "awake";
      } else {
          values[1] = "sleeping";
      }

      return `${strings[0]}${values[0]}${strings[1]}${values[1]}`
  }


  var message = tag`It's ${new Date().getHours()} I'm ${""}`;

  console.log(message);
#+end_src

#+RESULTS:
: It's 8 I'm awake
: undefined

* Array comprehension

  Not standard, do not use. Perhaps available in es7.

  #+begin_src js
    var nums = [1, 2, 3, 4, 5];
    var letters = ["a", "b", "c", "d", "e"];

    var battleship = [for(num of nums) [for(letter of letters) num + letter]];

    console.log(battleship);
    // [["1a", "1b", "1c", "1d", "1e"],
    //  ["2a", "2b", "2c", "2d", "2e"],
    //  ["3a", "3b", "3c", "3d", "3e"],
    //  ["4a", "4b", "4c", "4d", "4e"],
    //  ["5a", "5b", "5c", "5d", "5e"]]
  #+end_src

  #+RESULTS:

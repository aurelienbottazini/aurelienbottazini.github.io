#+BEGIN_HTML
---
layout: notes
---
#+END_HTML

Notes from /Refactoring – Improving the design of existing software/ by
/Martin Fowler/

List of soundbites p417

* Introduction
The first step in refactoring should be to build a solid set of tests
for that section of code. They should run quickly.

Good programmers write code that humans can understand

Temp variables lead to long classes

Don't worry about performance when refactoring. This is not your first
objective. Your first objective is code clarity.

Refactoring is to modify without changing observable behavior

When you develop you often have to switch between two hats:

  1. Adding functions
  2. Refactoring

Refactoring stops the design of the system from decaying, it also:

  1. Improves design
  2. Eases understanding
  3. Helps to find bugs
  4. Help to program faster

If you get a bug report, it is a sign you need refactoring

Not having enough time is usually a sign that you need refactoring

Secret to fast software: write tunable software first and then tune it
for sufficient speed.

Refactoring slows the software in the short term while you refactor.
But it makes it the software easier to tune during optimization.

Good programmers know that they rarely write clean code the first time around.

* Code smells

+ Duplicated code
+ Long method. Whenever you feel the need to comment something, write
  a method instead. Conditionals and loops are good sign for extraction.
+ Large class. Too many instance variables. Too much code.
+ Long parameter list. But be careful to not add an unwanted
  dependency by calling an object instead of passing a parameter.
+ Divergent change. When one class is commonly changed in different
  ways for different reasons.
+ Shotgun surgery. Every time you make a change you have to make a lot
  of little changes in a lot of different classes.
+ Feature Envy. A method that seems more interested in a class other
  than the one it actually is in.
+ Data clumps. Data that hang around in group together.
+ Primitive obsession. Break the line between primitives and larger classes
+ Switch statements. Consider polymorphism.
+ Parallel inheritance hierarchies. Every time you make a subclass you
  have to make a subclass of another.
+ Lazy class. Class that is not doing enough.
+ Speculative generality. Abstract classes that are not doing much.
+ Temporary field. An instance variable is set only in certain circumstances.
+ Message chains. One object ask for another object, which ask for
  another object, which…
+ Middleman. Half the methods are delegating to another class.
+ Inappropriate intimacy. Two classes know too much about each other.
+ Alternative classes. With different interfaces but they do the same thing.
+ Incomplete library class.
+ Data class. They need to take responsibility.
+ Refused request. Don’t want to support the interface of the superclass.
+ Comments. They are like deodorant. Use them to say why you did something.

* Tests

Tests should be fully automatic and they should test their own
results. They decapitate the time it takes to find bugs.

When you find a bug, write a unit test that exposes the bug.

Concentrate you tests on boundaries.

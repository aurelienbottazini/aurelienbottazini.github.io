#+BEGIN_HTML
---
layout: notes
---
#+END_HTML
#+TOC: headlines 4

* Polymorphism

  Objects from different classes can define methods that share the
  same name.

* Dynamic typing

  Defers the determination of the class that on object belongs to or type of
  data a variable holds until the program is executing.

  Variables can hold different type of values

* Static typing

  A variable is always used to store objects of the same type.

* Dynamic binding

  Defers the determination of the actual method to invoke on an object
  until program execution time.
* Hoisting
  Sets up memory space for variables (set to undefined) and functions.
* Single threaded
  One command at at time
* Synchronous
  One at a time and by order
* Variable environment
  Where the variable live and how they relate to each other
* Scope
  Where a variable is available in your code
* Asynchronous
  More than one at a time
* Primitive type
  Type of data that represents a single value (i.e not an object)
* Associativity
  What order operators or functions get called in: left-to-right or
  right-to-left
* Coercion
  Converting a value from one type to another
* Namespace
  A container for variables and functions. To keep variables and
  functions with the same name separate.
* First class functions
  Everything you can do with other types you can do with functions.
  For example, assign them to variables, pass them around, create them
  on the fly.
* Expression
  Unit of code that results in a value
* Mutate
  To change something
* Immutable
  Can't be changed
* Arguments
  The parameters you pass to a function
* Callback function
  A function you give to another function, to be run when the other
  function is finished.
* Function currying
  Creating a copy of a function but with some preset parameters.
* Inheritance
  One object gets access to the properties and methods of another object

** Classical inheritance (Java, Rubyâ€¦)
  pro: robust, current standard
  cons: Verbose

** Prototypal inheritance (JavaScript)
   simpler, flexible, extensible, easy to understand

* Reflection
  An object can look at itself, listing and changing its properties and
  methods

  ~your_object.hasOwnProperty('prop')~ check if prop is on your object and not
  on prototype

  With underscorejs you have the ~extend~ method. It allows you to combine
  objects. Extending the first object passed as a parameter with the
  following arguments.

#+begin_src js
  _.extend(object_to_extend, other_object, another_object);
#+end_src

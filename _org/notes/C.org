#+BEGIN_HTML
---
layout: notes
---
#+END_HTML
#+TOC: headlines 4

* Small but powerful

  C provides no operation to deal directly with composite objects such
  as character strings, sets, lists, or arrays.
  There is no heap or garbage collection.
  You need to explicitly use functions provided by most C
  implementations.

* Main
  Programs begin executing at the start of main. Every program must
  have a main somewhere.

#+BEGIN_SRC C
  #include <stdio.h>
  main ()
  {
    printf("hello, world\n");
  }
#+END_SRC

* Data types

   + ~char~ :: a single byte. A character written between single
               quotes represents an integer value equal to the
               numerical value of the character in the machine’s
               character set. It is called a /character constant/. It
               is another way to write a small integer. ~char~
               variables and constants are identical to ~int~ in
               arithmetic expressions. With ASCII, ~A~ value is 65,
               ~0~ value is 48 etc.

               #+BEGIN_SRC C
                 if (c >= '0' && c <= '9')
               #+END_SRC

               Determines whether the character in ~c~ is a digit. The
               numeric value of that digit is
               #+BEGIN_SRC C
                 c - '0'
               #+END_SRC
               Because the values of ~0~, ~1~, etc. form a contiguous
               increasing sequence.

   + ~int~ :: at least 16 bits (-32768 and +32767). 32 bits on some
              machine. An integer can be represented in octal with a
              leading ~0~. A leading ~0x~ means hexadecimal
   + ~short~ or ~short int~ :: short integer. Often 16 bits
   + ~long~ or ~long int~ :: at least 32 bits. Often 32 bits
   + ~float~ :: single-precision floating point
   + ~double~ :: double-precision floating point

   ~signed~ or ~unsigned~ can be applied to ~char~ or ~integer~.
   ~unsigned~ numbers are always positive  or zero and obey the laws
   of arithmetic modulo 2^n. So if /chars/ are 8 bits, ~unsigned char~
   variables have values between 0 and 255 (2^8 = 256). ~signed char~
   variables have values between -128 and 127.

   ~%~ cannot be applied to ~float~ or ~double~.

   Integer division truncates.

   #+BEGIN_SRC C :exports both
     float f = 5/2;
     printf("%f", f);
   #+END_SRC

   #+RESULTS:
   : 2.0

   #+BEGIN_SRC C
   n1 = nw = nc = 0;
   #+END_SRC

   Sets all variables to 0 because assignment is an expression with a value.

   By convention, a string constant ends with ~\0~ to mark the end.

   Type conversions can be forced (/coerced/) with an unary operator
   called a cast.

   #+BEGIN_SRC C
     sqrt((double) n)
   #+END_SRC

* ~++~ and ~--~
    To decrement ~--n~ and increment ~++n~ by 1. More concise and often efficient
    than ~n = n + 1~

    They can be used as prefix (~++n~) and postfix operators (~n++~).
    ~++n~ increments before the value is used

    #+BEGIN_SRC C :exports both
      int n = 5;
      int m = 5;

      printf("%d, %d", ++n, m++);
    #+END_SRC

    #+RESULTS:
    | 6 | 5 |

* Logical Operators ~||~ and ~&&~
    Evaluate from left to right and stop as soon as the truth or
    falsehood is known.

* Bitwise Operators

  + ~&~ :: bitwise AND. Often used to mask off some set of bits
           #+BEGIN_SRC C
             n = n & 0177; //sets to zero all but the low-order 7 bits of n
           #+END_SRC
  + ~|~ :: bitwise inclusive OR. Used to turn its on
           #+BEGIN_SRC C
             x = x | SET_ON; //set to one in x the bits that are set to one in SET_ON
           #+END_SRC
  + ~^~ :: bitwise exclusive OR. Sets a one in each bit position where
           its operands have different bits, and zero where they are
           the same
  + ~<<~ :: left shift. Shift to the left, filling vacated bits with
            zero. ~<< 2~ is equivalent to multiplication by 4 (2^2).
  + ~>>~ :: right shift. ~unsigned~ ensures right-shifted vacated bits
            will be filled with zero.
  + =~= :: one's complement (unary). Convert's each 1-bit into a 0-bit
           and vice versa.

* Constants

** Symbolic Constants
    ~#define~ defines a symbolic name or symbolic constant. They are
    conventionally written in UPPER CASE.

    #+BEGIN_SRC C
      #define LOWER 0
      #define UPPER 300
    #+END_SRC

    A long constant is written with a terminal ~l~ or ~L~. Unsigned
    constants are written with a terminal ~u~ or ~U~. For example ~ul~
    indicates ~unsigned long~.
    With a decimal point, ~f~ or ~F~ indicates float, ~l~ or ~L~
    indicate ~long double~.

** Enumeration constant

   #+BEGIN_SRC C
     enum boolean { NO, YES };
   #+END_SRC

   The first name in an ~enum~ has a value of 0, the next a value of 1
   and so on.

** ~const~

   The qualifier ~const~ can be applied to the declaration of any
   variable to specify that its value will not be changed.

   #+BEGIN_SRC C
     const double e = 2.483995598;
   #+END_SRC

   It can also be used with array arguments to indicate that the
   function does not change the array

   #+BEGIN_SRC C
     int strlen(const char[]);
   #+END_SRC

* Character Input and Output
** ~printf~ & ~scanf~

    First argument is a string of characters to be printed. Each ~%~
    indicating where one of the other arguments is to be substituted.

    #+BEGIN_SRC C
      printf("%d\t%d\n", 93, 24);
    #+END_SRC

    #+RESULTS:
    | 93 | 24 |


    Parameters examples
   + ~%d~ :: decimal integer
   + ~%6d~ :: decimal integer, 6 characters wide
   + ~f~ :: float
   + ~%6.2f~ :: float with 2 characters after decimal point and 6
                characters wide

   ~scanf~ is like ~printf~ except that it reads input instead of
   writing output.
** ~getchar~ and ~putchar~
    One character at a time

    #+BEGIN_SRC C :exports both
      putchar('c');
    #+END_SRC

    #+RESULTS:
    : c

    ~getchar~ returns ~EOF~ where there is no more input. We use ~int~
    to hold values from ~getchar~ because ~EOF~ is not big enough to
    hold ~EOF~

    #+BEGIN_SRC C
      c = getchar()
    #+END_SRC

    Since ~getchar~ has a value it can be used inside larger
    expression

    #+BEGIN_SRC C
      #include <stdio.h>
      main()
      {
        int c;
        while ((c = getchar()) != EOF)
          putchar(c);
      }
    #+END_SRC
* Functions
   A function does not need to return a value.
   A function returns 0 upon normal termination.

   #+BEGIN_SRC C
     int power(int, int);
   #+END_SRC
   This is a function prototype. Parameters names are optional in
   function prototype. But well-chosen names are *good documentation*.

   All function arguments are /passed by value/. It means the function
   uses temporary variables instead of the originals. *This is
   different with arrays*. The value passed is the location of the
   address of the beginning of the array. There is no copying of array
   elements.
* External variables

   An external variable must be defined exactly once. The variable
   must also be declared in each function that wants to access it.

   #+BEGIN_SRC C
     int max;

     main()
     {
       extern int max;
     }
   #+END_SRC

   The ~extern~ declaration can be omitted it the definition of the
   external variable occurs in the source file before the use in a
   particular function.
   A common practice is to place all external variables at the beginning
   of the source file and then omit all ~extern~ declarations.
   The usual practice is to collect all ~extern~ declarations of
   variables and functions in a separate file, an /header/ file.

* Types, Operators, and Expressions

  Don’t begin variable names with underscore, library routines often
  use such names. Traditional C practice is to use lower case for
  variable name and all upper case for symbolic constants.

  There are /assignment operators/
  #+BEGIN_SRC C
    i = i + 2;
    i += 2;
  #+END_SRC
  Available for
  : + - * / % << >> & ^ |

** Conditional expressions

   #+BEGIN_SRC C
     z = (a > b) ? a : b; // z = max(a,b)
   #+END_SRC
* Escape sequences

  + ~\a~ :: alert (bell) character
  + ~\b~ :: backspace
  + ~\f~ :: formfeed
  + ~\n~ :: newline
  + ~\r~ :: carriage return
  + ~\t~ :: horizontal tab
  + ~\v~ :: vertical tab
  + ~\\~ :: backslash
  + ~\?~ :: question mark
  + ~\' (single quote)~ :: single quote
  + ~\" (double quote)~ :: double quote
  + ~\ooo~ :: octal number
  + ~\xhh~ :: hexadecimal number

* String
  #+BEGIN_SRC C :exports both
    char string[] = "I’m a string";
    char another_string[] = "I’m " "a string";
    printf("%s", another_string);
  #+END_SRC

  #+RESULTS:
  : I’m a string

  null character ~\0~ at the end

* Control Flow

** ~if~
   #+BEGIN_SRC C :exports both
     int x = 6;
     if (x > 10)
       printf("large x");
      else  if (x > 5)
        printf("small x");
      else
        printf("tiny x");
   #+END_SRC

   #+RESULTS:
   : small x

** ~switch~
   As a matter of good form we put a ~break~ after the last case even
   though it is unnecessary.

   #+BEGIN_SRC C :exports both
     int c = 'a';

     switch(c) {
      case 'a':
        printf("this is a");
        break;
      case 'b': case 'c': case 'd':
        printf("not a");
        break;
      default:
        break;
      }

   #+END_SRC

   #+RESULTS:
   : this is a

   The ~break~ statements cause an immediate exit from the ~switch~.

** Loops

   #+BEGIN_SRC C
     while((c = getchar()) != EOF)
       {
         // do stuff
       }
   #+END_SRC

   There is a ~do while~ which execute a first time the loop before
   the loop condition is evaluated.

   #+BEGIN_SRC C
     int x = 0;
     do {
       // do something
       x++;
      } while (x > 10)
   #+END_SRC

   #+BEGIN_SRC C
     int i, j;

     for (i = 0, j = strlen(s)-1; i< j; i++, j--) {
       // do stuff
      }
   #+END_SRC

   Infinite loop:
   #+BEGIN_SRC C
     for (;;) {
      }
   #+END_SRC

** Break and continue

   The ~break~ statements cause an immediate exit from a ~switch~.
   It also forces an immediate exit from ~while~, ~for~ and ~do~ loops.

   A ~break~ causes the innermost enclosing loop or switch to be
   exited immediately.

   The ~continue~ statement causes the next iteration of the enclosing
   loop to begin immediately.

** Goto and Labels

   *Don't use them*

   #+BEGIN_SRC C
     goto found;

     found:
     // more code
   #+END_SRC
* Functions
  Minimal function, ~int~ return type is assumed:

  #+BEGIN_SRC C
  dummy () {}
  #+END_SRC

  #+BEGIN_SRC C
  double sum, atof(char[]);
  #+END_SRC

  means that sum is a ~double~ variable and that ~atof~ is a function
  that takes one ~char[]~ argument and returns a double.
  If there is no function prototype, a function is implicitly declared
  by its first appearance in an expression. This can lead to
  incoherent results.

  You can type /cast/ function results.
  #+BEGIN_SRC C
  return (int) atof(s);
  #+END_SRC

* Static variables
  Limits the scope of an external variable or function to the rest of
  the source file.
  You can also applied it to variables internal to a particular
  functions. They are local to the function but they remain in
  existence between function calls.

  #+BEGIN_SRC C
    static char buf[BUFSIZE];
  #+END_SRC

* Register variables

  Advises the compiler that the variable will be heavily used.
  Registers variables are to be placed in machine registers, results
  in smaller and faster programs. Too many ~register~ declarations are
  harmless (they are ignored).

  #+BEGIN_SRC C
    register int i;
  #+END_SRC

* Variable initialization
  Without explicit initialization, External and static variables are
  guaranteed to be initialized to zero. If they have an initializer it
  must be a constant expression.

  Automatic and register variables have undefined initial values.


  Array initialization examples
  #+BEGIN_SRC C
    int day[] = { 31, 28, 31, 30 };
    char pattern[] = "ould";
  #+END_SRC

* C pre-processor
** include
  ~#include<>~ searches in implementation defined directories. With
  quotes searches for source file where the source program was found
  then.

** define
  ~#define name replacement_text~ is for macro substitution. You can
  ~undef~ too to make sure a name is available (usually to ensure that
  a routine is a function not a macro).

  #+BEGIN_SRC C
    #define forever for(;;)
    #define max(A, B) ((A) > (B) ? (A) : (B))

    // # makes expr expanded into a quoted string
    #define dprint(expr) printf(#expr " = %g\n", expr)
    dprint(x/y);

    // ## concatenates arguments
    #define paste(front, back) front ## back
    paste(name1); //creates name1

    #undef forever
  #+END_SRC

** conditional inclusion

   Provides code inclusion during compilation.
   Can help to avoid including a file multiple times

   #+BEGIN_SRC C
     #if !define(HDR)
     #define HDR
     /* more code */
     #elif !define(LDR)
     /* more code */
     #endif

     #ifndef HDR
     #define HDR
     #endif

     #ifdef HDR
     #endif
   #+END_SRC
* Pointers and Arrays
  A pointer is a variable that contains the address of a variable.

  The unary operator ~&~ gives the address of an object. ~&~ only
  applies to objects in memory: variables and array elements.
  #+BEGIN_SRC C
    p = &c;
  #+END_SRC

  The adress of ~c~ is the variable ~p~ and p is said to /point to/ ~c~.

  The unary operator ~*~ is the /indirection/ or /de-referencing/
  operator. When applied to a pointer it accesses the object the
  pointer points to.

  A pointer to ~void~ is used to hold any type of pointer but cannot
  be de-referenced itself

  #+BEGIN_SRC C :exports both
    int x = 1, y = 2, z[10];
    int *ip, *iq;
    ip = &x;
    printf("%i\n", *ip);

    y = *ip;
    printf("%i\n", y);

    ,*ip = 0;
    printf("%i\n", x);

    z[0] = 9;

    ip = &z[0];
    printf("%i\n", *ip);

    ,*ip += 1;
    printf("%i\n", *ip);

    ++*ip;
    printf("%i\n", *ip);

    z[1] = 3;
    ,*ip++; // careful here, you increment ip, not what it points to
    printf("%i\n", *ip);

    (*ip)++;
    printf("%i\n", *ip);

    iq = ip; // making iq points to whatever ip points to
  #+END_SRC

  #+RESULTS:
  |  1 |
  |  1 |
  |  0 |
  |  9 |
  | 10 |
  | 11 |
  |  3 |
  |  4 |

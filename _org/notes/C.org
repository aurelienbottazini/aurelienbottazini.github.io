#+BEGIN_HTML
---
layout: notes
---
#+END_HTML
#+TOC: headlines 4

* Small but powerful

  C provides no operation to deal directly with composite objects such
  as character strings, sets, lists, or arrays.
  There is no heap or garbage collection.
  You need to explicitly use functions provided by most C
  implementations.

* Main
  Programs begin executing at the start of main. Every program must
  have a main somewhere.

#+BEGIN_SRC C
  #include <stdio.h>
  main ()
  {
    printf("hello, world\n");
  }
#+END_SRC

* Data types

   + ~char~ :: a single byte. A character written between single
               quotes represents an integer value equal to the
               numerical value of the character in the machine’s
               character set. It is called a /character constant/. It
               is another way to write a small integer. ~char~
               variables and constants are identical to ~int~ in
               arithmetic expressions. With ASCII, ~A~ value is 65,
               ~0~ value is 48 etc.

               #+BEGIN_SRC C
                 if (c >= '0' && c <= '9')
               #+END_SRC

               Determines whether the character in ~c~ is a digit. The
               numeric value of that digit is
               #+BEGIN_SRC C
                 c - '0'
               #+END_SRC
               Because the values of ~0~, ~1~, etc. form a contiguous
               increasing sequence.

   + ~int~ :: at least 16 bits (-32768 and +32767). 32 bits on some
              machine. An integer can be represented in octal with a
              leading ~0~. A leading ~0x~ means hexadecimal
   + ~short~ or ~short int~ :: short integer. Often 16 bits
   + ~long~ or ~long int~ :: at least 32 bits. Often 32 bits
   + ~float~ :: single-precision floating point
   + ~double~ :: double-precision floating point

   ~signed~ or ~unsigned~ can be applied to ~char~ or ~integer~.
   ~unsigned~ numbers are always positive  or zero and obey the laws
   of arithmetic modulo 2^n. So if /chars/ are 8 bits, ~unsigned char~
   variables have values between 0 and 255 (2^8 = 256). ~signed char~
   variables have values between -128 and 127.

   ~%~ cannot be applied to ~float~ or ~double~.

   Integer division truncates.

   #+BEGIN_SRC C :exports both
     float f = 5/2;
     printf("%f", f);
   #+END_SRC

   #+RESULTS:
   : 2.0

   #+BEGIN_SRC C
   n1 = nw = nc = 0;
   #+END_SRC

   Sets all variables to 0 because assignment is an expression with a value.

   By convention, a string constant ends with ~\0~ to mark the end.

   Type conversions can be forced (/coerced/) with an unary operator
   called a cast.

   #+BEGIN_SRC C
     sqrt((double) n)
   #+END_SRC

* ~++~ and ~--~
    To decrement ~--n~ and increment ~++n~ by 1. More concise and often efficient
    than ~n = n + 1~

    They can be used as prefix (~++n~) and postfix operators (~n++~).
    ~++n~ increments before the value is used

    #+BEGIN_SRC C :exports both
      int n = 5;
      int m = 5;

      printf("%d, %d", ++n, m++);
    #+END_SRC

    #+RESULTS:
    | 6 | 5 |

* Logical Operators ~||~ and ~&&~
    Evaluate from left to right and stop as soon as the truth or
    falsehood is known.

* Bitwise Operators

  + ~&~ :: bitwise AND. Often used to mask off some set of bits
           #+BEGIN_SRC C
             n = n & 0177; //sets to zero all but the low-order 7 bits of n
           #+END_SRC
  + ~|~ :: bitwise inclusive OR. Used to turn its on
           #+BEGIN_SRC C
             x = x | SET_ON; //set to one in x the bits that are set to one in SET_ON
           #+END_SRC
  + ~^~ :: bitwise exclusive OR. Sets a one in each bit position where
           its operands have different bits, and zero where they are
           the same
  + ~<<~ :: left shift. Shift to the left, filling vacated bits with
            zero. ~<< 2~ is equivalent to multiplication by 4 (2^2).
  + ~>>~ :: right shift. ~unsigned~ ensures right-shifted vacated bits
            will be filled with zero.
  + =~= :: one's complement (unary). Convert's each 1-bit into a 0-bit
           and vice versa.

* Constants

** Symbolic Constants
    ~#define~ defines a symbolic name or symbolic constant. They are
    conventionally written in UPPER CASE.

    #+BEGIN_SRC C
      #define LOWER 0
      #define UPPER 300
    #+END_SRC

    A long constant is written with a terminal ~l~ or ~L~. Unsigned
    constants are written with a terminal ~u~ or ~U~. For example ~ul~
    indicates ~unsigned long~.
    With a decimal point, ~f~ or ~F~ indicates float, ~l~ or ~L~
    indicate ~long double~.

** Enumeration constant

   #+BEGIN_SRC C
     enum boolean { NO, YES };
   #+END_SRC

   The first name in an ~enum~ has a value of 0, the next a value of 1
   and so on.

** ~const~

   The qualifier ~const~ can be applied to the declaration of any
   variable to specify that its value will not be changed.

   #+BEGIN_SRC C
     const double e = 2.483995598;
   #+END_SRC

   It can also be used with array arguments to indicate that the
   function does not change the array

   #+BEGIN_SRC C
     int strlen(const char[]);
   #+END_SRC

* Character Input and Output
** ~printf~ & ~scanf~

    First argument is a string of characters to be printed. Each ~%~
    indicating where one of the other arguments is to be substituted.

    #+BEGIN_SRC C
      printf("%d\t%d\n", 93, 24);
    #+END_SRC

    #+RESULTS:
    | 93 | 24 |


    Parameters examples
   + ~%d~ :: decimal integer
   + ~%6d~ :: decimal integer, 6 characters wide
   + ~f~ :: float
   + ~%6.2f~ :: float with 2 characters after decimal point and 6
                characters wide

   ~scanf~ is like ~printf~ except that it reads input instead of
   writing output.
** ~getchar~ and ~putchar~
    One character at a time

    #+BEGIN_SRC C :exports both
      putchar('c');
    #+END_SRC

    #+RESULTS:
    : c

    ~getchar~ returns ~EOF~ where there is no more input. We use ~int~
    to hold values from ~getchar~ because ~EOF~ is not big enough to
    hold ~EOF~

    #+BEGIN_SRC C
      c = getchar()
    #+END_SRC

    Since ~getchar~ has a value it can be used inside larger
    expression

    #+BEGIN_SRC C
      #include <stdio.h>
      main()
      {
        int c;
        while ((c = getchar()) != EOF)
          putchar(c);
      }
    #+END_SRC
* Functions
   A function does not need to return a value.
   A function returns 0 upon normal termination.

   #+BEGIN_SRC C
     int power(int, int);
   #+END_SRC
   This is a function prototype. Parameters names are optional in
   function prototype. But well-chosen names are *good documentation*.

   All function arguments are /passed by value/. It means the function
   uses temporary variables instead of the originals. *This is
   different with arrays*. The value passed is the location of the
   address of the beginning of the array. There is no copying of array
   elements.
** variable length argument lists

   Possible with ~...~. Must appear at the end of the argument list

   ~va_list~ is used to declare a variable that will refer to each
   argument in turn. ~va_start~ initializes ~ap~ to point to the first
   unnamed argument.

   #+BEGIN_SRC C
     int minprintf(char *fmt, ...)
       {
         va_list ap; // points to each argument in turn.
         va_start(ap, fmt); //makes app point to 1st unnamed arg in turn.
         va_arg(ap , double); // returns one argument and steps ap to the next
         va_end(ap); // clean up when done
       }
   #+END_SRC

* External variables

   An external variable must be defined exactly once. The variable
   must also be declared in each function that wants to access it.

   #+BEGIN_SRC C
     int max;

     main()
     {
       extern int max;
     }
   #+END_SRC

   The ~extern~ declaration can be omitted it the definition of the
   external variable occurs in the source file before the use in a
   particular function.
   A common practice is to place all external variables at the beginning
   of the source file and then omit all ~extern~ declarations.
   The usual practice is to collect all ~extern~ declarations of
   variables and functions in a separate file, an /header/ file.

* Types, Operators, and Expressions

  Don’t begin variable names with underscore, library routines often
  use such names. Traditional C practice is to use lower case for
  variable name and all upper case for symbolic constants.

  There are /assignment operators/
  #+BEGIN_SRC C
    i = i + 2;
    i += 2;
  #+END_SRC
  Available for
  : + - * / % << >> & ^ |

** Conditional expressions

   #+BEGIN_SRC C
     z = (a > b) ? a : b; // z = max(a,b)
   #+END_SRC
* Escape sequences

  + ~\a~ :: alert (bell) character
  + ~\b~ :: backspace
  + ~\f~ :: formfeed
  + ~\n~ :: newline
  + ~\r~ :: carriage return
  + ~\t~ :: horizontal tab
  + ~\v~ :: vertical tab
  + ~\\~ :: backslash
  + ~\?~ :: question mark
  + ~\' (single quote)~ :: single quote
  + ~\" (double quote)~ :: double quote
  + ~\ooo~ :: octal number
  + ~\xhh~ :: hexadecimal number

* String
  #+BEGIN_SRC C :exports both
    char string[] = "I’m a string";
    char another_string[] = "I’m " "a string";
    printf("%s", another_string);
  #+END_SRC

  #+RESULTS:
  : I’m a string

  null character ~\0~ at the end

* Control Flow

** ~if~
   #+BEGIN_SRC C :exports both
     int x = 6;
     if (x > 10)
       printf("large x");
      else  if (x > 5)
        printf("small x");
      else
        printf("tiny x");
   #+END_SRC

   #+RESULTS:
   : small x

** ~switch~
   As a matter of good form we put a ~break~ after the last case even
   though it is unnecessary.

   #+BEGIN_SRC C :exports both
     int c = 'a';

     switch(c) {
      case 'a':
        printf("this is a");
        break;
      case 'b': case 'c': case 'd':
        printf("not a");
        break;
      default:
        break;
      }

   #+END_SRC

   #+RESULTS:
   : this is a

   The ~break~ statements cause an immediate exit from the ~switch~.

** Loops

   #+BEGIN_SRC C
     while((c = getchar()) != EOF)
       {
         // do stuff
       }
   #+END_SRC

   There is a ~do while~ which execute a first time the loop before
   the loop condition is evaluated.

   #+BEGIN_SRC C
     int x = 0;
     do {
       // do something
       x++;
      } while (x > 10)
   #+END_SRC

   #+BEGIN_SRC C
     int i, j;

     for (i = 0, j = strlen(s)-1; i< j; i++, j--) {
       // do stuff
      }
   #+END_SRC

   Infinite loop:
   #+BEGIN_SRC C
     for (;;) {
      }
   #+END_SRC

** Break and continue

   The ~break~ statements cause an immediate exit from a ~switch~.
   It also forces an immediate exit from ~while~, ~for~ and ~do~ loops.

   A ~break~ causes the innermost enclosing loop or switch to be
   exited immediately.

   The ~continue~ statement causes the next iteration of the enclosing
   loop to begin immediately.

** Goto and Labels

   *Don't use them*

   #+BEGIN_SRC C
     goto found;

     found:
     // more code
   #+END_SRC
* Functions
  Minimal function, ~int~ return type is assumed:

  #+BEGIN_SRC C
  dummy () {}
  #+END_SRC

  #+BEGIN_SRC C
  double sum, atof(char[]);
  #+END_SRC

  means that sum is a ~double~ variable and that ~atof~ is a function
  that takes one ~char[]~ argument and returns a double.
  If there is no function prototype, a function is implicitly declared
  by its first appearance in an expression. This can lead to
  incoherent results.

  You can type /cast/ function results.
  #+BEGIN_SRC C
  return (int) atof(s);
  #+END_SRC

* Static variables
  Limits the scope of an external variable or function to the rest of
  the source file.
  You can also applied it to variables internal to a particular
  functions. They are local to the function but they remain in
  existence between function calls.

  #+BEGIN_SRC C
    static char buf[BUFSIZE];
  #+END_SRC

* Register variables

  Advises the compiler that the variable will be heavily used.
  Registers variables are to be placed in machine registers, results
  in smaller and faster programs. Too many ~register~ declarations are
  harmless (they are ignored).

  #+BEGIN_SRC C
    register int i;
  #+END_SRC

* Variable initialization
  Without explicit initialization, External and static variables are
  guaranteed to be initialized to zero. If they have an initializer it
  must be a constant expression.

  Automatic and register variables have undefined initial values.


  Array initialization examples
  #+BEGIN_SRC C
    int day[] = { 31, 28, 31, 30 };
    char pattern[] = "ould";
  #+END_SRC

* C pre-processor
** include
  ~#include<>~ searches in implementation defined directories. With
  quotes searches for source file where the source program was found
  then.

** define
  ~#define name replacement_text~ is for macro substitution. You can
  ~undef~ too to make sure a name is available (usually to ensure that
  a routine is a function not a macro).

  #+BEGIN_SRC C
    #define forever for(;;)
    #define max(A, B) ((A) > (B) ? (A) : (B))

    // # makes expr expanded into a quoted string
    #define dprint(expr) printf(#expr " = %g\n", expr)
    dprint(x/y);

    // ## concatenates arguments
    #define paste(front, back) front ## back
    paste(name1); //creates name1

    #undef forever
  #+END_SRC

** conditional inclusion

   Provides code inclusion during compilation.
   Can help to avoid including a file multiple times

   #+BEGIN_SRC C
     #if !define(HDR)
     #define HDR
     /* more code */
     #elif !define(LDR)
     /* more code */
     #endif

     #ifndef HDR
     #define HDR
     #endif

     #ifdef HDR
     #endif
   #+END_SRC
* Pointers and Arrays
  A pointer is a variable that contains the address of a variable.
  The addition and subtraction of two pointers is illegal.

  The unary operator ~&~ gives the address of an object. ~&~ only
  applies to objects in memory: variables and array elements.
  #+BEGIN_SRC C
    p = &c;
  #+END_SRC

  The adress of ~c~ is the variable ~p~ and p is said to /point to/ ~c~.

  The unary operator ~*~ is the /indirection/ or /de-referencing/
  operator. When applied to a pointer it accesses the object the
  pointer points to.

  A pointer to ~void~ is used to hold any type of pointer but cannot
  be de-referenced itself

  #+BEGIN_SRC C :exports both
    int x = 1, y = 2, z[10];
    int *ip, *iq;
    ip = &x;
    printf("%i\n", *ip);

    y = *ip;
    printf("%i\n", y);

    ,*ip = 0;
    printf("%i\n", x);

    z[0] = 9;

    ip = &z[0];
    printf("%i\n", *ip);

    ,*ip += 1;
    printf("%i\n", *ip);

    ++*ip;
    printf("%i\n", *ip);

    z[1] = 3;
    ,*ip++; // careful here, you increment ip, not what it points to
    printf("%i\n", *ip);

    (*ip)++;
    printf("%i\n", *ip);

    iq = ip; // making iq points to whatever ip points to
  #+END_SRC

  #+RESULTS:
  |  1 |
  |  1 |
  |  0 |
  |  9 |
  | 10 |
  | 11 |
  |  3 |
  |  4 |


  You can use pointers to have function parameters changed by
  functions.

  #+BEGIN_SRC C
    void swap(int *px, int *py)
    {
      temp = *px;
      *px = *py;
      *py = temp;
    }

    swap(&a, &b); // & produces the address of a bariable, so &a is a pointer to a
  #+END_SRC

  The constant zero may be assigned to a pointer, and a pointer can be
  compared to zero. The Symbolic constant ~NULL~ is often used in
  place of zero.

  Common idiom:
  #+BEGIN_SRC C
    // copy t to s
    void strcpy(char *s, char *t)
    {
      while (*s++ = *t++)
        ;
    }
  #+END_SRC

  Copies two strings, works because, strings ends with ~\0~ in C, So
  the loop will continue as long as ~\0~ in t has not been reached.

  #+BEGIN_SRC C
    *p++ = val; // push val on stack
    val = *--p  // pop top of stack into val
                // (decrements p before fetching the character that p points to)
  #+END_SRC

** Pointers and Arrays

   If ~pa~ points to an element to an array then by definition ~pa+i~
   points i elements after ~pa~.

   The correspondence between indexing and pointer arithmetic is very
   close. The value of a variable or expression of type array is the
   address of element zero of the array

   So the following two are equivalent
   #+BEGIN_SRC C
     pa = &a[0];
     pa = a
   #+END_SRC

   Similarly you can convert ~a[i]~ to ~*(a+i)~ and that’s what C does.
   The difference between an array name and a pointer is that a
   pointer is a variable to ~pa = a~ and ~pa++~ are legal but ~a = pa~
   and ~a++~ are illegal.

   The following two are equivalent
   #+BEGIN_SRC C
     char s[];
     char *s;
   #+END_SRC

   You can pass a sub-array to a function by passing a pointer to the
   beginning of the sub-array.

   #+BEGIN_SRC C
     f(&a[2]);
   #+END_SRC

   #+BEGIN_SRC C
   char *lineptr[MAXLINES] // each element is a pointer to a char
   #+END_SRC

   With two-dimensional arrays, you don't have to pass the number of
   rows (irrelevant since what is passed is a pointer to an array of
   rows — viewed as columns), only the number of columns.

   #+BEGIN_SRC C
     f(int daytab[][13]);
     //or
     f(int (*daytab)[13]);
   #+END_SRC


   ~[]~ has higher precedence than ~*~.
   #+BEGIN_SRC C
     int *daytab[13];   //Array of 13 pointers to integers
   #+END_SRC

   With
   #+BEGIN_SRC C
   int a[10][20];
   int *b[10];
   #+END_SRC
   ~a~ has 200 int-sized locations.
   ~b~ has 10 pointers and does not initialize them. Rows of the array
   can be of different lengths.

** Pointers to function
   A function is not a variable but it is possible to define pointers
   to functions. And the generic pointer type ~void *~ is used for the
   pointer arguments.

   #+BEGIN_SRC C
     void qsort(void *v[], int left, int right, int (*comp)(void *, void *));


     // example usage
     char *lineptr[MAXLINES];
     qsort((void **) lineptr, 0, nlines-1, (int (*)(void*, void*)) (numeric ? numcmp : strcmp));
   #+END_SRC

   ~strcmp~ and ~numcmp~~ are addresses of functions.

   #+BEGIN_SRC C
     int (*comp)(void *, void *)
   #+END_SRC

   says that ~comp~ is a pointer to a function that has two ~void *~
   arguments and returns an int.

   Very different from

   #+BEGIN_SRC C
     int *comp(void *, void *)
   #+END_SRC

   Here ~comp~ is a function returning a pointer to an int.

* Command line arguments
  When ~main~ is called it has two arguments

  + ~argc~ :: the number of command line arguments
  + ~argv~ :: a pointer to an array of character strings that contain
              the arguments.

  By convention ~argv[0]~ is the name by which the program was
  invoked.
  ~argv[argc]~ is a null pointer.

* Structures
  A ~struct~ declaration defines a type

  #+BEGIN_SRC C :exports both
    struct point {
      int x;
      int y;
    } x, y , z;

    struct point maxpt = { 320, 200 };

    printf("%d, %d", maxpt.x, maxpt.y);
  #+END_SRC

  #+RESULTS:
  | 320 | 200 |

  With a large structure, it is generally more efficient to pass a
  pointer.

  #+BEGIN_SRC C
    struct point *pp;
    pp->x = 300;
    pp-> y = 200;
  #+END_SRC

  Example of a tree
  #+BEGIN_SRC C
    struct tnode {
      char *word;
      int count;
      struct tnode *left;
      struct tnode *right;
    };
  #+END_SRC

* ~typdedef~

  ~typdedef~ is for creating new data type names.

  #+BEGIN_SRC C
    typedef int Length;
    Length len, maxlen;
  #+END_SRC

  Reasons to use ~typedefs~:
  + Aesthetic issues
  + Parameterize a program against portability problems.
  + Provide better documentation for a program.

* ~union~
  A union is a variable that hold objects of different types and
  sizes.

  #+BEGIN_SRC C
    union u_tag {
      int ival;
      float fval;
      char *sval;
    } u;
  #+END_SRC

  Unions are accessed just as for structures with ~.~ and ~->~.
  An ~union~ may occur withing structures and arrays.

* ~sizeof~

  Can be used to compute the size of any object.

  #+BEGIN_SRC C :exports both
    int x = 3;
    printf("%d\n", sizeof x);
    printf("%d", sizeof(int));
  #+END_SRC

  #+RESULTS:
  | 4 |
  | 4 |

* Storage / memory management
  #+BEGIN_SRC C
    // returns a pointer to n bytes of uninitialized storage
    void *malloc(size_t n);
    // returns enough space for an array of n objects ot the specified size
    void *calloc(size_t n, site_t size);

    // frees the space pointed to by p
    free(p);
  #+END_SRC

  ~malloc~  and ~calloc~ return ~NULL~ if no space is available.

* ~install~ and ~lookup~

  #+BEGIN_SRC C
    #define IN 1
  #+END_SRC

* Input and Output

  + ~int getchar(void)~ :: read one character at a time. Returns ~EOF~
       when it encounters end of file. Can be directed to a file with
       ~<~. ~prog < infile~

  + ~int putchar(int)~ :: returns the character written or ~EOF~ if an
       errors occur. Can be directed to a file with ~>~. ~prog >
       outfile~

  + ~|~ :: runs two programs and pipes the standard output of the
           first one into the standard input for the second one.
           ~other_prog | prog~. ~other_prog~ output is the input of ~prog~.

  + ~int printf(char *format, arg1, arg2, …)~ :: converts format and prints its arguments on the
                standard output under control of the format.
                ~printf("%s", s)~.

  + ~int scanf(char *format, ...)~ :: analog of ~printf~. There is also
       ~sscanf~ which reads from a string instead of standard input.
       *Each other argument must be a pointer*. One of the most common
       error is to forget ~&~ on arguments.
       #+BEGIN_SRC C
         // & not needed for monthname since an array name is a pointer
         scanf("%d %s %d", &day, monthname, &year)
       #+END_SRC

  + ~FILE *fopen(char *name, char *mode)~ :: mode includes ~("r")~,
       ~("w")~, ~("a")~. If a file does not exists for writing or
       appending it is created. Opening a file for writing causes the
       old content to be discarded. If there is any error, ~fopen~
       returns ~NULL~.
       #+BEGIN_SRC C
       fp = fopen(name, mode);
       #+END_SRC

  + ~int getc(FILE *fp)~ :: returns next character from the steam
       ~fp~. ~EOF~ for end of file or error.

  + ~int putc(int c, FILE *fp)~ :: writes c to the file ~fp~ and
       returns character written or ~EOF~ on error.

  + ~fscanf~ and ~fprintf~:: similar to ~printf~ and ~scanf~ but for
    files.

  + ~in fclose(FILE *fp)~ :: don’t forget to close your file!

  + ~int ferror(FILE *fp)~ :: returns non zero if an error occurred on
       the stream ~fp~.

  + ~int feof(FILE *fp)~ :: returns non-zero if end of file error has
       occurred on ~fp~.

  + ~char *fgets(char *line, int maxline, FILE *fp)~ :: read the next
       input line. Returns ~NULL~ on end of file or error.

  + ~int fputs(char *line, FILE *fp)~ :: writes a string. Returns
       ~EOF~ if an error occurs. 0 otherwise.

  + ~int ungetc(ing c, FILE *fp)~ :: pushes c back onto file fp and
       returns either c or ~EOF~ for error.



** low level I/O

  The maximum length of a filename component is ~NAME_MAX~ which is
  system dependent and defined in ~dirent.h~

*** Read and Write

   #+BEGIN_SRC C
     int n_read = read(int fd, char *buf, int n);
     int n_written = write(int fd, char *buf, int n);
   #+END_SRC

   ~fd~ can be 0, 1 and 2 for standard input, output and standard
   error (don’t forget you can redirect program input and output with
   ~<~ and ~>~ ). Each calls returns the number of calls transferred.
   The most common values for the number o bytes to e written are 1
   (un-buffered), 1024 and 4096 that corresponds to physical block
   size on a peripheral device. ~BUFSIZ~ defined in ~syscalls.h~ is a
   good size for the local system.

   #+BEGIN_SRC c
   #include "syscalls.h"
   char buf[BUFSIZ];
   read(0, buf, BUFSIZ);
   write(1, buf, BUFSIZ);
   #+END_SRC

*** ~open~, ~creat~, ~close~, ~unlink~

    ~open~ is like ~fopen~ except it returns a file descriptor instead
    of a file pointer. It returns -1 if an error occurs. It is an
    error to open a file that does not exist.

    #+BEGIN_SRC C
      #include <fcnt1.h>
      int fd;
      int open(char *name, int flags, int perms);
      fd = open(name, O_RDONLY, 0);
    #+END_SRC

    Main flags are ~O_RDONLY~, ~OWRONLY~ and ~ORDWR~.

    ~creat~ is used to create new files or to rewrite old ones

    #+BEGIN_SRC C
      int creat(char *name, int perms);
      // create files with permissions specified by perms (like chmod)

      fd = creat(name, perms);
    #+END_SRC

    There is a limit to the number of file that a program can have
    open simultaneously (often about 20).

    ~close(int fd)~ breaks the connection between file descriptor and
    an open file.

    ~unlink(char *name)~ removes the file name from the file system.
    Equivalent to standard library ~remove~.

*** ~lseek~ and ~fseek~
    Provides a way to move around in a file without reading or writing
    any data

    #+BEGIN_SRC C
    long lseek(int fd, long offset, int origin);
    #+END_SRC

    ~origin~ can be 0, 1, 2 for beginning, current position or end of
    file.

    #+BEGIN_SRC C
      //OL can be written as 0 ifn lseek is properly declared.
      lseek(fd, 0L, 2); //end of file
      lseek(fd, 0L, 0); // beginning of file
    #+END_SRC

    The return value gives the new position in the file or -1 if an
    error occurs.

    ~fseek~ is similar to ~lseek~ except that the first argument is a
    ~File *~ and it returns non zero if an error occurred.

* String operations
  From ~<string.h>~

  + ~strcat(s,t)~ :: concatenate t to end of s
  + ~strncat(s,t,n)~ :: concatenate only n characters of t to end of s
  + ~strcmp(s,t)~ :: return negative, zero or positive for ~s < t~, ~s
                     == t~ and ~s > t~
  + ~strncmp(s,t,n)~ :: compare only first n characters
  + ~strcpy(s,t)~ :: copy t to s
  + ~strncpy(s,t,n)~ :: copy at most n characters of t to s
  + ~strlen(s)~ :: length of s
  + ~strchr(s,c)~ :: return pointer to first c in s, ~NULL~ if not present
  + ~strrchr(s,c)~ :: return pointer to last c in s, ~NULL~ if not present

* Character testing
  From ~<ctype.h>~

  + ~isalpha(c)~ :: non zero if c is alphabetic
  + ~isupper(c)~ :: non zero if c is upper case
  + ~islower(c)~ :: non zero if c is lower case
  + ~isdigit(c)~ :: nonzero if c is digit
  + ~isalnum(c)~ :: non zero if c is alphabetic or digit
  + ~isspace(c)~ :: non zero for blank, tab, newline, return,
                    formfeed, vertical tab
  + ~toupper(c)~ :: return c converted to upper case
  + ~tolower(c)~ :: return c converted to lower case

* exit
  Terminates program execution when it is used.

  #+BEGIN_SRC C
    exit(0)
  #+END_SRC

  ~exit~ calls ~fclose~ for each open output file to flush out any
  buffered output

* system
  Execute command on local operating system.

  #+BEGIN_SRC C
    system("date");
  #+END_SRC

* Mathematical functions
  From ~<math.h>~

  + ~sin(x)~
  + ~cos(x)~
  + ~atan2(y/x)~ /arctangent/
  + ~exp(x)~ e^x
  + ~log(x)~
  + ~log10(x)~
  + ~pow(x,y)~ x^y
  + ~sqrt(x)~
  + ~fabs(x)~ absolute value of x

* Random numbers
  #+BEGIN_SRC C
    // random integers in the range zero to RAND_MAX
    rand()

    // random float numbers greater than or equal to zero but less than one
    #define frand() ((double) rand() / (RAND_MAX+1.0))

    // sets the seed for rand
    srand(unsigned);
  #+END_SRC

#+BEGIN_HTML
--- layout: notes ---
#+END_HTML
#+TOC: headlines 4


/Writing GNU Emacs Extensions: Editor Customizations and Creations with Lisp
(Nutshell Handbooks)/ – Bob Glickstein

Lisp is more concise: (+ a b c d e)

The single keystroke META-x can always be replaced with the two-key sequence ESC
x.

C-z has a default binding of iconify-or-deiconify-frame when running under X,
and suspend-emacs when running in a character terminal. In both cases, the
function is also bound to C-x C-z, so there’s no need to rebind them.

You can use the *scratch* buffer. This buffer is automatically created when
Emacs starts. The buffer is in Lisp Interaction mode. In this mode, pressing C-j
invokes eval-print-last-sexp, which is like eval-last-sexp except that the
result of the evaluation is inserted into the buffer at the location of the
cursor.

apropos is invoked with a prefix argument, it not only reports Emacs functions
and variables that match the search pattern, it also reports any existing
keybindings for each command in the list.

* Nil

 The symbol nil is special in Lisp for three reasons: a value of nil means
 “false” and any other value means “true.”

 Inside the Lisp interpreter, the symbol nil and the empty list () are the same
 object.

 It is its own value. When you evaluate the symbol nil, the result is nil. For
 this reason, unlike other symbols, nil doesn’t need to be quoted when you want
 its name instead of its value, because its name is the same as its value.

 So you can write (setq x nil)      ;assign nil to variable x instead of writing
 (setq x 'nil)

  “truth” in Lisp can be represented by any expression except nil,

  The empty list () is synonymous with the symbol nil. This does not mean that
  () is the same as (nil).

* Interactive

  The code letter p used in this example means, “if there is a prefix argument,
  interpret it as a number, and if there is no prefix argument, interpret that
  as the number 1.”

  It’s important to understand the difference between the two expressions (- n)
  and -1. The first is a function call. There must be a space between the
  function name and the argument. The second expression is an integer constant.
  There may not be a space between the minus sign and the 1. It is certainly
  possible to write (- 1) (though there’s no reason to incur the cost of a
  function call when you can alternatively write -1). It is not possible to
  write -n, because n is not a constant.

  The capital P means “when called interactively, leave the prefix argument in
  raw form and assign it to n.” The raw form of a prefix argument is a data
  structure used internally by Emacs to record the prefix information the user
  gave before invoking a command.

  The asterisk, when it is the first character in an interactive argument, means
  “abort this function if the current buffer is read-only.”

  The @ in the interactive declaration means, “Before doing anything else, find
  the mouse click (if any)

  The code letter e tells interactive to bundle up the mouse event that invoked
  this command as a list and assign it to event.

* Parameters

  The keyword &optional appearing in a parameter list means that all subsequent
  parameters are optional.

* Tricks

  In general, (if test     (a  b)   (a  c)) can be shortened to (a (if test b
  c)).


  An old Lisp programmers’ trick can now be used to make this expression even
  more concise: (if n n 1) ≡ (or n 1)


  Lisp’s or has an extra bit of usefulness: it evaluates each of its arguments
  in order until it finds one that’s non-nil, then it returns that value. If it
  doesn’t find one, it returns nil.


  generally speaking,


  (if a  a  b) can be replaced by (or a  b)


  (if a  a                 ;if a is true, return a   (if b  b              
  ;else if b is true, return b     ...       (if y  y  z)))     ;else if y is
  true, return y, else z (which might look artificial here but is actually a
  pretty common pattern in actual programs) can be changed to the following
  form. (or a  b ... y  z) subject to the warning about evaluating expressions
  multiple times. Similarly, (if a   (if b     ...       (if y  z))) (note that
  none of the ifs in this example has an “else” clause) can also be written as
  (and a  b ... y  z) because and works by evaluating each of its arguments in
  order until it finds one that’s nil. If it finds one, it returns nil, and if
  it doesn’t find one, it returns the value of the last argument.

* defalias

  We can use defalias to refer to any Lisp function by a different name.
  (defalias 'scroll-ahead 'scroll-up) (defalias 'scroll-behind 'scroll-down)

* functions

  “Point” refers to the position of the cursor.

  The function file-symlink-p tests whether its argument, which is a string
  naming a file, refers to a symbolic link. It’s a Boolean predicate, meaning it
  returns true or false. In Lisp, predicates traditionally have names ending in
  p or -p.

  A progn expression evaluates each of its subexpressions in order and returns
  the value of the last one.

  It’s possible to define a function without giving it a name. Such functions
  are appropriately known as anonymous functions. They’re created with the Lisp
  keyword lambda

  An anonymous function definition can be used wherever you might use the name
  of a function:

  There’s one reason not to use anonymous functions in hooks. If you ever wish
  to remove a function from a hook, you need to refer to it by name in a call to
  remove-hook, like so: (remove-hook 'find-file-hooks 'read-only-if-symlink)

  The insert function takes any number of arguments (which must all be strings
  or characters) and inserts them one after another in the current buffer at the
  present location of point, moving point forward.

  The keyword &rest, followed by a parameter name, must appear last in a
  function’s parameter list. It means “collect up any remaining arguments into a
  list and assign it to the last parameter”

  The function crossword--set has a double hyphen in its name. This is the
  conventional way to denote a "private” function that isn’t part of a package’s
  advertised programming interface.

* Hooks

  post-command-hook is a list of functions to run after every interactive
  command.

  Using M-x apropos RET hook RET,

  A buffer-local version of write-file-hooks. Recall from the Hooks section of
  Chapter 2 that a buffer-local variable is one that can have different values
  in different buffers.

  Thus, if you want to run one function while saving a Lisp file and another one
  when saving a text file, local-write-file-hooks is the one to use.

  functions in local-write-file-hooks (also in write-file-hooks and
  write-contents-hooks), a non-nil return value means, “This hook function has
  taken over the job of writing the buffer to a file.”

  Although ordinary variables are made buffer-local with either
  make-local-variable or make-variable-buffer-local (see below), hook variables
  must be made buffer-local with make-local-hook.

* Temp variables


  In Lisp, temporary variables are created with let, whose syntax is (let
  ((var1 value1)       (var2 value2)       ...       (varn valuen))
    body1 body2 ... bodyn)

* advice

  A piece of advice attached to a Lisp function is code that gets executed
  before or after the function each time the function is invoked. Before advice
  can affect the arguments before they’re passed to the advised function. After
  advice can affect the return value that comes out of the advised function.
  Advice is a little bit like hook variables, but whereas Emacs defines only a
  few dozen hook variables for very particular circumstances, you get to choose
  which functions get “advised.”

* defvar, setq, global variable

  We’ll use defvar to declare the variable.

  Setting a variable’s default value with defvar is different from setting a
  variable’s value with setq. Instead of unconditionally assigning the value to
  the variable like setq does, defvar assigns the value only if the variable
  does not yet have any value.

  (*). A leading asterisk has special meaning in defvar docstrings. It means
  that the variable in question is a user option.

* Window
  Emacs provides several functions describing what’s visible in a window, such
  as window-edges, window-height, and current-window-configuration.

* Command

  ~last-command~

  this-command the variable that contains the name of the current command
  invoked by the user.

* Properties

  In addition to having a variable value and/or a function definition, every
  Emacs Lisp symbol may also have associated with it a property list.

  Properties are stored with the put function and retrieved with the get
  function.

* Markers

  markers. A marker is a special object that specifies a buffer position just
  like an integer does. But if the buffer position moves because of insertions
  or deletions, the marker “moves” too so that it keeps pointing to the same
  spot in the text.

* Time

  Emacs includes a few other time-related functions, notably current-time, which
  yields the current time in a raw form, and format-time-string, which can take
  such a time and format it in a wide variety of ways (in the style of C’s
  strftime).

* Save-excursion / data / restriction

  What save-excursion does is memorize the position of the cursor, execute the
  subexpressions it’s given as arguments, then restore the cursor to its
  original position.

  save-restriction. This is like save-excursion in that it memorizes some
  information, then executes its arguments, then restores the information. The
  information in this case is the buffer’s restriction, which is the result of
  narrowing.

  save-match-data that, like save-excursion and save-restriction, memorizes some
  information, executes its arguments, then restores the information. This time
  the information in question is the result of the latest search.

* Regexp

  Emacs provides a function for this purpose called regexp-quote, which
  understands regexp syntax and can turn a possibly-magic string into the
  corresponding non-magic one.

* After change

  after-change-functions contains functions to call after each buffer change.

  This use of let creates a temporary variable, after-change-functions, that
  supersedes the global after-change-functions during the call to
  update-modifystamps in the body of the let. After the let exits, the temporary
  after-change-functions disappears and the global one is again in effect.

* Require and Provide


  require and provide, give a way to make sure it only gets loaded once instead
  of n times.

  (provide 'timestamp) (require 'timestamp "timestamp")

  The string equivalent of the feature symbol timestamp is "timestamp", so we
  can write (require 'timestamp) instead of (require 'timestamp "timestamp").
  (The function symbol-name called on a symbol yields its string equivalent.)

* User options

  Hooking user options into the “customize” system requires using special
  functions called defgroup and defcustom.

* Autoloading

  You ask Emacs to find a Lisp file in the load path and you omit the suffix of
  the file for which you’re looking — e.g., you specify foo instead of foo.el —
  Emacs first looks for foo.elc, the byte-compiled form of foo.el. If that’s not
  found in the load path, then foo.el is tried, followed by plain foo. It’s
  usually best to omit the suffix when specifying a file to load. Not only does
  it get you that useful search behavior, but it helps eval-after-load to work
  properly

  With autoloading, you can arrange to defer loading a file until it’s needed —
  that is, until you call one of its functions. Setting up autoloads is very
  inexpensive, and therefore is usually done in the .emacs file.

  The function autoload connects a function name with the file that defines it.

  The autoload function has several optional parameters. The first one is a
  docstring for the not-yet-defined function.

  The next optional parameter describes whether the function, once loaded, will
  be an interactive command or a mere function.

  The last optional parameter is one we won’t cover for now. It specifies the
  type of the autoloadable object, if not a function. As it turns out, keymaps
  and macros (which we’ll cover in coming chapters) may also be autoloaded.

  If you’d like to defer the execution of some code until a particular file has
  been loaded, eval-after-load is the way to do it.

  The load or autoload or require that causes dired to be loaded must refer to
  it by exactly the same name used in eval-after-load.

  Another use for eval-after-load is when you need to refer to a variable,
  function, or keymap in a package that’s not loaded yet, and you don’t want to
  force the package to be loaded:

* byte-compile

  There are several ways to byte-compile files. The most straightforward ways
  are From within Emacs: Execute M-x byte-compile-file RET file.el RET. From the
  UNIX shell: Run emacs -batch -f batch-byte-compile file.el.


  You can byte-compile an entire directory full of Lisp files with
  byte-recompile-directory.

* File variable

  Whenever Emacs visits a new file, it scans near the end[22] for a block of
  text that looks like this: Local variables: var1: value1 var2: value2 ... End:
  When Emacs finds such a block, it assigns each value to the corresponding var,
  which is automatically made buffer-local.

  Emacs can recognize this block even if each line begins with a prefix, as long
  as they all begin with the same prefix. This is necessary in a file of Lisp
  code, for example, to comment out the lines so they’re not interpreted as
  Lisp:

  Any file that needs update-writestamps in its local-write-file-hooks could
  therefore specify: Local variables: local-write-file-hooks:
  (update-writestamps) End: In fact, a file could set up all of the unique
  values it needs: Local variables: local-write-file-hooks: (update-writestamps)
  writestamp-prefix: "Written:" writestamp-suffix: "." writestamp-format: "%D"
  End:


  Emacs recognizes a “pseudovariable” in the local variables list called eval.
  When eval: value

  eval: (add-hook 'local-write-file-hooks 'update-writestamps)

* List

  car yields the first element in a list, and cdr yields the remainder of the
  list

  (Recall that quoting an expression — even a complete list — means to use that
  expression literally. So '(a b c) means the list containing a, b, and c, not
  the result of calling function a on arguments b and c.)

  Lists are constructed with the functions list, cons, and append.


  The function list makes a list out of any number of arguments:


  The function cons takes an arbitrary Lisp expression and an existing list. It
  makes a new list by prepending the arbitrary expression to the old list:


  The function append takes any number of lists and makes a new list by
  concatenating the top-level elements of all the lists.


  The function reverse takes a list and makes a new list by reversing its
  top-level elements.


  Lists are composed of smaller data structures called cons cells. A cons cell
  is a structure that contains two Lisp expressions, referred to, you may not be
  surprised to learn, as the cell’s car and cdr.


  There’s a special syntax for cons cells whose cdrs aren’t lists. It’s called
  dotted pair notation, and cons cells themselves are sometimes referred to as
  dotted pairs:


  A list where the last cdr is not nil is sometimes called an improper list.
  Frequently, the entries in an association list (see below) are improper lists.

  consp tests whether its argument is a cons cell. (consp x) is true when x is
  any list except the empty list, and false for all other objects. atom tests
  whether its argument is atomic. (atom x) is the opposite of (consp x) —
  everything that’s not a cons cell, including nil, numbers, strings, and
  symbols, is an atom. listp tests whether its argument is a list. (listp x) is
  true for all cons cells and for nil, false for everything else.

  null tests whether its argument is nil.

  Other Useful List Functions Here are some more list-related Lisp functions
  that Emacs defines.

  Enter setcar and setcdr. [26] Given a cons cell and a new value, these
  functions replace the cell’s car or cdr with the new value.

  There is one other important destructive list operation: nreverse,

  A list can be made to refer to part of itself! Consider: (setq x '(a b c))
  (nthcdr 2 x) ⇒ (c) (setcdr (nthcdr 2 x) x)      ;don't try this yet!

  What does this list look like? Well, it starts out like this: (a b c a b c a b
  c a b c a b c a b c a b c a b c ... and it never stops.

* Syntax table

  syntax table is a mode-specific mapping from characters to “syntax classes.”


  The syntax table is used by commands like forward-word and backward-word to
  figure out just what a word is. Because different buffers can have different
  syntax tables, the definition of a word can vary from one buffer to another.

  The function char-syntax returns a character’s syntax code as another
  character.

* Macro function

  It is possible to write a special kind of function, called a macro
  function,[31] that behaves as though its arguments are quoted. That is, when a
  macro function is invoked, its arguments are not evaluated before the function
  gets control.

  Macro functions are defined with defmacro (whose syntax resembles defun). The
  way to write incr is: (defmacro incr (var)   "Add one to the named variable."
    (list 'setq var (list '+ var 1)))

  The body of a macro function produces an expansion of its input. The expansion
  then gets evaluated. The expansion of (incr x) is: (setq x (+ x 1)) When that
  expression is evaluated, x is incremented.

  You can debug macro functions using the function macroexpand.

* Backquote

  Backquote is just like quote, meaning that the result of evaluating a
  backquoted expression is the expression itself: `(a  b  c) ⇒ (a  b  c) There
  is one important difference, however. A backquoted list’s subexpressions may
  be individually unquoted using yet more special syntax. This means that when
  the backquoted expression is evaluated, the unquoted subexpressions actually
  do get evaluated — but the rest of the list remains quoted! `(a ,b  c) ⇒ (a
  value-of- b c)

* Remove outer parentheses

  What we need instead is a way to splice the value of subexprs into the
  surrounding list, removing the outer parentheses. For this purpose, Emacs Lisp
  has one more special bit of syntax (last one, I promise): the splicing unquote
  operator, ,@.

* Let

  With let*, there is no ambiguity: the order in which the vals are evaluated is
  the same as the order in which they’re written.[

  The way to create such a symbol is with the function make-symbol, which takes
  the symbol’s name (as a string) and creates a brand-new, uninterned object
  guaranteed not to be equal, in the sense of eq, to any other Lisp object.

* Fail gracefully

  It is possible to write Lisp code that gets executed while the stack is being
  unwound! This is the key to writing code that fails "gracefully,” cleaning up
  after itself if it doesn’t get the chance to finish due to some error (or due
  to the user interrupting the operation with C-g). The function to use is
  called unwind-protect,

* defalias

  (defalias 'backward-quip 'backward-page) (defalias 'forward-quip
  'forward-page) (defalias 'narrow-to-quip 'narrow-to-page) (defalias 'what-quip
  'what-page)

* Keymap

  The global keymap, mentioned above, is always active. It can be superseded by
  entries in a buffer’s local keymap, which contains special keybindings for the
  current major mode. That, in turn, can be superseded by the entries in the
  minor mode keymap corresponding to any minor modes that are active.[37


  We use make-sparse-keymap because Quip mode has only a few special keybindings
  beyond the ones found in the global keymap. Only when a keymap has more than a
  couple dozen keybindings should a full keymap be created with make-keymap.

  If users wish to alter Quip mode’s keybindings, they can do so using a mode
  hook and local-set-key (which, within Quip mode, alters quip-mode-map):

  substitute-key-definition does. (substitute-key-definition 'beginning-of-line
                             'crossword-beginning-of-row

  This situation is partially alleviated with suppress-keymap, which causes all
  self-inserting keys to become undefined. We should call suppress-keymap
  immediately after creating the keymap, before starting to define keys in it.
  (if crossword-mode-map     nil   (setq crossword-mode-map (make-keymap))
    (suppress-keymap crossword-mode-map)   ...) This only gets rid of
  self-inserting keys, leaving other dangerous keys like C-w and C-y lurking
  about. A more complete (and more drastic) solution is to place a catch-all
  binding in crossword-mode-map: (define-key crossword-mode-map [t] 'undefined)
  In this call to define-key,

* derive-mode

  it’s so common to derive new modes by varying existing ones — just as we’ve
  varied Text mode to get Quip mode — that there’s an Emacs Lisp package to
  simplify this task. The package is called derived and the central function it
  provides is called define-derived-mode.

* Vectors

  Vectors are self-evaluating; that is, the result of evaluating a vector is the
  vector itself. Its subexpressions are not evaluated. So if you write: [a b c]
  you’ll get a vector containing the three symbols, a, b, and c. If you want a
  vector containing the values of variables a, b, and c, you must construct the
  vector using the vector function: (vector a b c) ⇒ [17 37 42]

* Inline functions

  When function definitions are very short, like these last four, it’s usually a
  good idea to turn them into inline functions using defsubst instead of defun.

* Equivalence pairs

  We create a list of "equivalence pairs” in equivs.

* Mouse

  When you press a key, you generate a numeric code that can be used to index
  the vector, or it can be used as the search key in an assoc search. When you
  press a mouse button, you generate a symbol that can only be used in an assoc
  search. The symbol down-mouse-1, for instance, represents a press of mouse
  button 1 (usually the left mouse button), while the symbol mouse-1 represents
  button 1 being released. (It is customary for a button press to initiate an
  action by noting the position of the mouse pointer, and for a button release
  to complete an action by noting whether the mouse has moved since the
  corresponding button press.) Other mouse-event symbols include C-down-mouse-2
  (pressing the middle mouse button while holding the control key),
  S-drag-mouse-3 (shift key plus mouse motion with button 3 depressed), and
  double-mouse-1 (after releasing mouse button 1 for the second time in a
  double-click). Another difference between mouse input and keyboard input is
  that when you press a mouse button, there is additional data associated with
  the button press: for instance, there’s the location in the window where you
  pressed it. Keyboard input always happens at “point,” but mouse input happens
  wherever the mouse is. For this reason, mouse input is represented by a data
  structure called an input event. A command bound to a mouse action can access
  the current event by calling last-input-event, or by using the e code letter
  in its interactive declaration.



  Menu keymaps must have an "overall prompt string.” That’s the meaning of the
  optional argument "Crossword" in this call to make-sparse-keymap.


(define-key crossword-mode-map [menu-bar crossword]             (cons
"Crossword" crossword-menu-map))

* Asynchronous

  An asynchronous process object is a Lisp data structure that represents
  another running program on your computer. New processes are created with
  start-process, which resembles call-process (which we saw in the previous
  section). Unlike call-process, however, start-process does not wait for the
  executed program to complete. Instead, it returns a process object.

* Process
  One more thing about start-process. When Emacs creates the process, it
  maintains a connection to it (through which input and output flow) using
  either UNIX pipes or UNIX pseudo-ttys. Pipes are more appropriate for
  non-interactive processes like egrep, while pseudo-ttys, or ptys, are more
  appropriate for interactive programs — e.g., command interpreters like the
  UNIX shell. The kind of connection that is created by start-process is
  controlled by the variable process-connection-type — nil means use pipes, t
  means use ptys.

  Though it’s a little baroque, it’s a good idea always to wrap calls to
  start-process inside a let call where you temporarily set
  process-connection-type to the desired value, as in: ... (let
  ((process-connection-type nil))   (start-process "egrep"                 
  buffer                  crossword-egrep-program                  "-i" regexp
  crossword-words-file)) ...

** Sentinel

   sentinel is a Lisp function that gets called when the process changes state.
   We’re interested in the state change that happens when the program exits; but
   state changes can also happen when the process receives a signal.

   (set-process-sentinel process                         
    'crossword--egrep-sentinel))))))))

   We can define crossword--egrep-sentinel as: (defun crossword--egrep-sentinel
   (process string)   "When PROCESS exits, display its buffer."   (if (eq
   (process-status process)           'exit)       (display-buffer
   (process-buffer process))))

* Filter

  A filter is a function that gets called whenever output from the process
  arrives.

  (set-process-filter process                         'crossword--egrep-filter)

  (defun crossword--egrep-filter (process string)   "Handle output from
  PROCESS."    (let ((buffer (process-buffer process)))     (save-excursion     
   (set-buffer buffer)       (goto-char (point-max))       (insert string))   
   (display-buffer buffer)))

* Eval lisp

  Lisp expression in any buffer can be evaluated by placing the cursor at the
  end of the expression and pressing C-x C-e (eval-last-sexp). The keystroke M-:
  (eval-expression) prompts for a Lisp expression to evaluate in the minibuffer.
  You can also use the commands eval-region and eval-current-buffer.

  M-x lisp-interaction-mode RET). In that mode, C-j is normally
  eval-print-last-sexp, which is like eval-last-sexp except that it also inserts
  the result of evaluation into the buffer.

  You can use the command eval-last-sexp, which is bound to C-x C-e.
  eval-expression, which is bound to M-:[

* debugger

  Entering the debugger is controlled as follows. debug-on-entry

  debug-on-error

  debug-on-next-call

  debug-on-quit This

  Edebug is an elaborate debugging environment that is far more powerful than
  the debugging facilities described in the previous section.

* Profiling

  Barry Warsaw has written an ingenious package for profiling Emacs Lisp called
  ELP. This syntax is magic. When the docstring is displayed to the user — such
  as when the user uses apropos or describe-variable — \[command] is replaced
  with a representation of a keybinding that invokes command. For example, if
  C-x t invokes insert-time, then the docstring "*Format for \\[insert-time]
  (c.f. 'format-time-string')." is displayed as *Format for C-x t (c.f.
  'format-time-string').
